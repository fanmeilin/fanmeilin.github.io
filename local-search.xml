<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Sobel算子</title>
    <link href="/2021/08/14/img_process/sobel/"/>
    <url>/2021/08/14/img_process/sobel/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍Sobel算子，主要用于边缘检测；由于该算子引入了局部平均，对噪声有平滑作用，因此还可以消除噪声。</p></blockquote><h2 id="图像边缘与梯度"><a href="#图像边缘与梯度" class="headerlink" title="图像边缘与梯度"></a>图像边缘与梯度</h2><p>在图像边缘，灰度值的变化较大，因此图像在此处的梯度值也较大。一般情况，图像梯度时计算图像的边缘信息。图像梯度严格来说时需要求导数，但是在图像计算上时使用像素值的差得到梯度的近似值。<br>图像强度的显著变化可分为：</p><ul><li>阶跃变化函数，即图像强度在不连续处的两边的像素灰度值有着显著的差异；</li><li>线条（屋顶）变化函数，即图像强度突然从一个值变化到另一个值，保持一较小行程后又回到原来的值。</li></ul><p><img src="http://qxtgssh6h.hn-bkt.clouddn.com/sobel1.png"></p><p>（a）（b）分别是阶跃函数和屋顶函数的二维图像；（c）（d）是阶跃和屋顶函数的函数图象；（e）（f）对应一阶倒数；（g）（h）是二阶倒数。</p><h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><p>常用如下两个模板进行边缘检测，将Gx，Gy与图像卷积，即可得到横向和纵向的亮度差分近似值。</p>$$G_x = \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -2 &amp; 0 &amp; 2\\-1 &amp; 0 &amp; 1\end{bmatrix} \qquad G_y = \begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 0 &amp; 0 &amp; 0\\-1 &amp; -2 &amp; -1\end{bmatrix}$$<p>图像每一个像素的梯度可以使用$G = \sqrt{G^2_x+G^2_y}$来表示，梯度的方向使用$\Theta = arctan(\frac{G_y}{G_x})$。</p><p>还有另外一个比<code>Sobel</code>函数的近似效果更好的 <code>Scharr</code>函数，其内核矩阵如下:</p>$$G_x = \begin{bmatrix} -3 &amp; 0 &amp; 3 \\ -10 &amp; 0 &amp; 10 \\ -3 &amp; 0 &amp; 3\end{bmatrix} \qquad G_y = \begin{bmatrix} -3 &amp; -10 &amp; -3 \\ 0 &amp; 0 &amp; 0 \\ 3 &amp; 10 &amp; 3\end{bmatrix}$$<h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><h3 id="cv2-Sobel"><a href="#cv2-Sobel" class="headerlink" title="cv2.Sobel()"></a>cv2.Sobel()</h3><p>Sobel算子依然是一种过滤器，只是其是带有方向的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.Sobel(src, ddepth, dx, dy[,ksize[, scale[, delta[, borderType]]]])<br></code></pre></td></tr></tbody></table></figure><ul><li>dst代表目标函数</li><li> src代表原始图像</li><li> ddpeth代表输出图像的深度 ，-1表示采用的是与原图像相同的深度。目标图像的深度必须大于等于原图像的深度；</li><li>  dx代表x方向上的求导阶数 ，0表示这个方向上没有求导，一般为0、1、2。</li><li>  dy代表y方向上的求导阶数，0表示这个方向上没有求导，一般为0、1、2。</li><li>  ksize代表Sobel核的大小，该值为-1时，则会使用Scharr算子进行运算,一般选择为1、3、5、7</li><li>  scale代表计算导数时所采用的缩放因子，默认为1，无缩放</li><li> delta代表加在目标图像dst上的值，该值是可选的，默认为0</li><li> borderType代表边界样式，这个参数默认值为cv2.BORDER_DEFAULT。</li></ul><blockquote><p>其中ddepth设计图像深度的概念：<br>图像深度是指存储每个像素值所用的位数，例如cv2.CV_8U，指的是8位无符号数，取值范围为0~255，超出范围则会被截断（截断指的是，当数值大于255保留为255，当数值小于0保留为0，其余不变）。</p><p>具体还有：CV_16S（16位无符号数），CV_16U（16位有符号数），CV_32F（32位浮点数），CV_64F（64位浮点数）等.</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-comment">#载入原图，图像深度为CV_8U</span><br>img_original=cv2.imread(<span class="hljs-string">'E:\ShannonT\\notebook workspace\\images\\4.28.9.jpg'</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#求X方向梯度，并且输出图像一个为CV_8U,一个为CV_64F</span><br>img_gradient_X_8U=cv2.Sobel(img_original,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>img_gradient_X_64F=cv2.Sobel(img_original,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#将图像深度改为CV_8U</span><br>img_gradient_X_64Fto8U=cv2.convertScaleAbs(img_gradient_X_64F)<br><span class="hljs-comment">#图像显示</span><br>cv2.imshow(<span class="hljs-string">'X_gradient_8U'</span>,img_gradient_X)<br>cv2.imshow(<span class="hljs-string">'X_gradient_64Fto8U'</span>,img_gradient_X_64Fto8U)<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20191103142600352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzQxNDIz,size_16,color_FFFFFF,t_70"></p><p><code>cv2.imshow()</code>的默认显示为8位无符号数，即[0,255]，因此在显示<code>CV_64F</code>的图像前使用了函数<code>cv2.convertScaleAbs()</code>将图像深度为<code>CV_64F</code>的梯度图像重新转化为<code>CV_8U</code>。</p><h3 id="cv2-convertScaleAbs"><a href="#cv2-convertScaleAbs" class="headerlink" title="cv2.convertScaleAbs()"></a>cv2.convertScaleAbs()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cv2.convert<span class="hljs-constructor">ScaleAbs(<span class="hljs-params">src</span>[,<span class="hljs-params">alpha</span>[,<span class="hljs-params">beta</span>]])</span><br></code></pre></td></tr></tbody></table></figure><p>先计算数组绝对值，后转化为8位无符号数</p><ul><li>src:输入图像（多维数组）</li><li>alpha:比例因子</li><li>beta:保存新图像（数组）前可以增加的值</li></ul><h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><p>防止梯度大小被截断最简单的方法就是先将输入图像归一化（实际归一化的过程就已经实现了图像深度的转变）。在使用深度大于8U的格式之前将灰度先归一化，就不用<code>convertScaleAbs</code>转换了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#载入灰度原图，图像深度为CV_8U</span><br>img_original=cv2.imread(<span class="hljs-string">'E:\ShannonT\\notebook workspace\\images\\4.28.9.jpg'</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#原图归一化,实际图像深度已经变为CV_64F</span><br>img_standard=img_original/<span class="hljs-number">255</span><br><span class="hljs-comment">#采用灰度原图求X方向梯度</span><br>original_gradient_X_64F=cv2.Sobel(img_original,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>original_gradient_X_64Fto8U=cv2.convertScaleAbs(original_gradient_X_64F)<br><span class="hljs-comment">#采用归一化的图像求X方向梯度</span><br>standard_gradient_X=cv2.Sobel(img_standard,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#图像显示</span><br>cv2.imshow(<span class="hljs-string">'original'</span>,img_original)<br>cv2.imshow(<span class="hljs-string">'original_X'</span>,original_gradient_X_64Fto8U)<br>cv2.imshow(<span class="hljs-string">'standard_X'</span>,standard_gradient_X)<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20191103144005627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzQxNDIz,size_16,color_FFFFFF,t_70"></p><h3 id="cv2-addWeighted"><a href="#cv2-addWeighted" class="headerlink" title="cv2.addWeighted()"></a>cv2.addWeighted()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cv2.add<span class="hljs-constructor">Weighted(<span class="hljs-params">src1</span>, <span class="hljs-params">alpha</span>, <span class="hljs-params">src2</span>, <span class="hljs-params">beta</span>, <span class="hljs-params">gamma</span>[, <span class="hljs-params">dst</span>[, <span class="hljs-params">dtype</span>]])</span> → dst<br></code></pre></td></tr></tbody></table></figure><ul><li>src1 输入的第一个数组</li><li>alpha 第一个数组的权重</li><li>src2 输入的第二个数组（与第一个数组有相同的shape）</li><li>beta 第二个数组的权重</li><li>dst 输出的数组名称</li><li>gamma 计算和时所采用的缩放因子，默认为1，无缩放</li><li>dtype 输出图像的深度，-1表示和input相同</li><li><blockquote><p>dst = src1 * alpha + src2 * beta + gamma;</p></blockquote></li></ul><p>注意：由参数说明可以看出，被叠加的两幅图像必须是尺寸相同、类型相同的；并且，当输出图像array的深度为CV_32S时，这个函数就不适用了，这时候就会内存溢出或者算出的结果压根不对。</p><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p>通过cv2.Sobel()我们可以轻松计算出X,Y方向的梯度大小，根据公式</p><p>$$<br>G = \sqrt{G^2_x+G^2_y}<br>$$<br>可以求出梯度图像，实际操作时，为了简化运算，我们使用公式</p><p>$$<br>G = \vert{G_x}\vert+\vert{G_y}\vert<br>$$</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#载入灰度原图，并且归一化</span><br>img_original=cv2.imread(<span class="hljs-string">'E:\ShannonT\\notebook workspace\\images\\4.28.9.jpg'</span>,<span class="hljs-number">0</span>)/<span class="hljs-number">255</span><br><span class="hljs-comment">#分别求X,Y方向的梯度</span><br>grad_X=cv2.Sobel(img_original,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>grad_Y=cv2.Sobel(img_original,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">#求梯度图像</span><br>grad=cv2.addWeighted(grad_X,<span class="hljs-number">0.5</span>,grad_Y,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>)<br>cv2.imshow(<span class="hljs-string">'gradient'</span>,grad)<br></code></pre></td></tr></tbody></table></figure><h2 id="官方说明"><a href="#官方说明" class="headerlink" title="官方说明"></a>官方说明</h2><p>当年作者并没有公开发表过论文，仅仅是在一次博士生课题讨论会(1968)上提出(“A 3x3 Isotropic Gradient Operator for Image Processing”)，后在1973年出版的一本专著（”Pattern Classification and Scene Analysis”）的脚注里作为注释出现和公开的。</p><p>详细介绍，请参考以下内容。</p><p><a href="http://qxrol67de.hn-bkt.clouddn.com/An%20Isotropic%203x3%20Image%20Gradient%20Operator.pdf">文章链接</a></p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer06 从尾到头打印链表</title>
    <link href="/2021/08/14/leetcode/leetcode-offer06/"/>
    <url>/2021/08/14/leetcode/leetcode-offer06/</url>
    
    <content type="html"><![CDATA[<blockquote><p>从尾到头打印链表</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>0 &lt;= 链表长度 &lt;= 10000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>遍历链表，直接插入到头位置。就可以直接输出了。或者采用递归，超级简洁，值得借鉴。注意if的条件和对应结果。（递归就从中间普适的节点开始考虑 然后补充边界细节）</p><p><font color="orange">return self.reversePrint( head.next ) + [ head.val ] if head else []</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reversePrint</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        """</span><br>        p=head<br>        result = []<br>        <span class="hljs-keyword">while</span>(p):<br>            result = [p.val]+result <span class="hljs-comment">#直接添加到前面</span><br>            p = p.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> result<br>        <span class="hljs-comment">#使用递归一条语句超级简洁 递归后一个元素+当前元素 如果当前为空则+【】 也是终止未知</span><br>        <span class="hljs-comment">#return self.reversePrint(head.next) + [head.val] if head else []</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>idea</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer12 矩阵中的路径</title>
    <link href="/2021/08/14/leetcode/leetcode-offer12/"/>
    <url>/2021/08/14/leetcode/leetcode-offer12/</url>
    
    <content type="html"><![CDATA[<blockquote><p>矩阵中的路径</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"E"</span>],[<span class="hljs-string">"S"</span>,<span class="hljs-string">"F"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"S"</span>],[<span class="hljs-string">"A"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"E"</span>]], word = <span class="hljs-string">"ABCCED"</span><br>输出：true<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">board</span> = [[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>]], <span class="hljs-attr">word</span> = <span class="hljs-string">"abcd"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>循环遍历二维数组，以此为起点判断是否存在连续的字符串。在dfs中首先进行边界范围判断，以及此点是否满足要求，如果不满足要求直接返回假，为真则继续word判断之后的字符。如果以及是最后的字符就可以直接返回结果。<font color="purple">注意在判断k+1之前需要先mask掉自身的值，防止后续“路线返回”</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exist</span>(<span class="hljs-params">self, board, word</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type board: List[List[str]]</span><br><span class="hljs-string">        :type word: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">i,j,k</span>):</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(board)&gt;i&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])&gt;j&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> board[i][j]!=word[k]: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span> <br>            <span class="hljs-comment">#不匹配的情况</span><br>            <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word)-<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-comment">#不用继续判断</span><br>            board[i][j] = <span class="hljs-string">' '</span><br>            <span class="hljs-comment"># #注意不能直接返回 因为在处理邻近的内容会判断到自身，这是不允许的，所以先mask</span><br>            <span class="hljs-comment"># return dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1) </span><br>            res = dfs(i+<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> dfs(i-<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> dfs(i,j+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> dfs(i,j-<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) <br>            board[i][j] = word[k]<br>            <span class="hljs-keyword">return</span> res<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> dfs(i,j,<span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-comment">#如果从ij开始找0之后的字符串找到则为真</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>DFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>idea</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer11 旋转数组的最小数字</title>
    <link href="/2021/08/13/leetcode/leetcode-offer11/"/>
    <url>/2021/08/13/leetcode/leetcode-offer11/</url>
    
    <content type="html"><![CDATA[<blockquote><p>旋转数组的最小数字</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将数组遍历一遍，遇到第一个非增序的元素即为最小值。复杂度为线性级别。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minArray</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(numbers):<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        minitem = numbers[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(numbers)):<br>            <span class="hljs-keyword">if</span> numbers[i]&lt;numbers[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(minitem,numbers[i])<br>        <span class="hljs-keyword">return</span> minitem<br></code></pre></td></tr></tbody></table></figure><p>还可以使用二分法，将线性级别的复杂度降低到对数级别。</p><p><img src="https://pic.leetcode-cn.com/1599404042-JMvjtL-Picture1.png" alt="Picture1.png"></p><p>最低点有特性：左边的所有元素都要比右边所有元素大。利用这个特性可以逐渐缩小范围。</p><p>中间元素和某个边界元素比较大小，来确定范围，<u>但是要注意两者相等时就没有确切的判断了</u>。可以直接用线性比较来替代。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minArray</span>(<span class="hljs-params">self, numbers: [<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> numbers[m] &gt; numbers[j]: i = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> numbers[m] &lt; numbers[j]: j = m<br>            <span class="hljs-keyword">else</span>: j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> numbers[i]<br></code></pre></td></tr></tbody></table></figure><p>实际上，当出现 nums[m] = nums[j] 时，一定有区间[i,m]内所有元素相等 或 区间 [m,j] 内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minArray</span>(<span class="hljs-params">self, numbers: [<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> numbers[m] &gt; numbers[j]: i = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> numbers[m] &lt; numbers[j]: j = m<br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(numbers[i:j])<br>        <span class="hljs-keyword">return</span> numbers[i]<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>数组</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文献整理笔记</title>
    <link href="/2021/08/13/deep_learning/paper-site/"/>
    <url>/2021/08/13/deep_learning/paper-site/</url>
    
    <content type="html"><![CDATA[<blockquote><p>查找文献的网站<br><a href="https://www.thecvf.com/">https://www.thecvf.com/</a><br><a href="https://arxiv.org/list/cs/recent">https://arxiv.org/list/cs/recent</a><br><a href="https://www.researchgate.net/">https://www.researchgate.net/</a></p></blockquote><h3 id="微调技巧"><a href="#微调技巧" class="headerlink" title="微调技巧"></a>微调技巧</h3><p><a href="http://qxrol67de.hn-bkt.clouddn.com/Accurate%2C%20Large%20Minibatch%20SGD%20Training%20ImageNet%20in%201%20Hour.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:MibpfCuStpYUbfD8qs8aMC3U2y0="><strong>Accurate, Large Minibatch SGD Training ImageNet in 1 Hour.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/BITGeneral%20Visual%20Representation%20Learning.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:m9ZxInQumMS8DO8NwtI9HvuyxCY="><strong>BIT : General Visual Representation Learning.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/Co-Tuning%20for%20Transfer%20Learning.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:zKqFz-uPhbE5o_oUWYs8uAT9aXc="><strong>Co-Tuning for Transfer Learning.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/EfficientNet%20Rethinking%20Model%20Scaling%20for%20Convolutional%20Neural%20Networks.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:K_nkiBpr-4L07Xa_VRoN4xsRNU4="><strong>EfficientNet Rethinking Model Scaling for Convolutional Neural Networks.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:38vBt7XcdylOUC5C_pFcevVpXas="><strong>He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/Simple%20Copy-Paste%20is%20a%20Strong%20Data%20Augmentation%20Method.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:NRT0zKN1hdhwyUU8KzKb6aGBC1M="><strong>Simple Copy-Paste is a Strong Data Augmentation Method.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/Discriminative%20Feature%20Alignment%20Improving%20Transferability%20of.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:mU7vMQVsm3DEXt7QHTqtzDNaogg="><strong>Discriminative Feature Alignment Improving Transferability of.pdf</strong></a><br><a href="http://qxrol67de.hn-bkt.clouddn.com/Movement%20Pruning%20adaptive%20sparsity%20by%20fine-tuning.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:UFJJB_PWAAbWqCS7RZUwswuBNTM="><strong>Movement Pruning adaptive sparsity by fine-tuning.pdf</strong></a></p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p><a href="http://qxrol67de.hn-bkt.clouddn.com/attention%20is%20all%20you%20need1706.03762.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:2eZzguYiYMcXj1n-OLDZwUFwGYU="><strong>Attention Is All You Need</strong></a> (讲解Attention机制)</p><p> <a href="http://qxrol67de.hn-bkt.clouddn.com/AN%20IMAGE%20IS%20WORTH%2016X16%20WORDS.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:NUSVTIvWzrJf2Zv031E5YW2RlFA="><strong>AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT</strong></a>（将transformer应用于图像分类）</p><p><a href="http://qxrol67de.hn-bkt.clouddn.com/transformer%20%E6%80%BB%E7%BB%93.pdf?e=1628844027&amp;token=XOjUoKvaLFMqS1LkRGv-hKeP9QfGCl4I7Lq18FO5:WSUaru3yoQne8yY-qSfnsfNChL4="><strong>A Survey of Transformers</strong></a>（Transformer的总结）</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fine-tuning的方法</title>
    <link href="/2021/08/13/deep_learning/fine-tuning/"/>
    <url>/2021/08/13/deep_learning/fine-tuning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>收集关于深度学习的调参的相关笔记，主要用于网络训练的微调。</p></blockquote><h3 id="训练技巧"><a href="#训练技巧" class="headerlink" title="训练技巧"></a><strong>训练技巧</strong></h3><p>1.要做<strong>梯度归一化</strong>,即算出来的梯度除以minibatch size</p><p>2.clip c(梯度裁剪): 限制最大梯度,其实是value = sqrt(w1^2 +w2^2….),如果value超过了阈值,就算一个衰减系数,让value的值等于阈值: 5,10,15</p><p><strong>3.防止过拟合</strong></p><p>​    一般常用的防止过拟合方法有使用<strong>L1正则项、L2正则项、dropout、提前终止、数据集扩充等</strong>。如果模型在训练集上表现比较好但在测试集上表现欠佳可以选择增大L1或L2正则的惩罚力度（<strong>L2正则经验上首选1.0</strong>，超过10很少见），或<strong>增大dropout的随机失活概率</strong>（经验首选0.5）；或者当随着训练的持续在测试集上不增反降时，使用提前终止训练的方法。当然<strong>最有效的还是增大训练集的规模</strong>，实在难以获得新数据也可以使用数据集增强的方法，比如CV任务可以对数据集进行裁剪、翻转、平移等方法进行数据集增强，这种方法往往都会提高最后模型的测试精度。<br>     dropout对小数据防止过拟合有很好的效果,值一般设为0.5,小数据上dropout+sgd。在大部分实验中，效果提升都非常明显.<strong>建议尝试</strong>。 dropout的位置比较有讲究, 对于RNN,建议放到输入-&gt;RNN与RNN-&gt;输出的位置.关于RNN如何用dropout,可以参考:<a href="https://link.zhihu.com/?target=http://arxiv.org/abs/1409.2329">http://arxiv.org/abs/1409.2329</a>(Captain Jack令言:(不仅仅可以防止过拟合, 其实这相当于做人力成本最低的Ensemble, 当然, 训练起来会比没有Dropout的要慢一点, 同时网络参数你最好相应加一点, 对, 这会再慢一点).)</p><p><strong>4.超参</strong> </p><p>​    learning rate 最重要<strong>，推荐了解 cosine learning rate 和 cyclic learning rate，其次是 <strong>batchsize 和 weight decay</strong>。当你的模型还不错的时候，可以试着做数据增广和改损失函数锦上添花了。(罗浩ZJU令言：随着网络训练的进行，学习率要逐渐降下来；网络性能越好，学习率要越小（即越需要微调而非粗调)；batchsize通常影响没那么大，塞满卡就行，除了特殊的算法需要batch大一点)<br>​    adam,adadelta等,在小数据上,我这里实验的效果不如sgd, sgd收敛速度会慢一些，但是最终收敛后的结果，一般都比较好。</strong>如果使用sgd的话,可以选择从1.0或者0.1的学习率开始,隔一段时间,在验证集上检查一下,如果cost没有下降,就对学习率减半**. 我看过很多论文都这么搞,我自己实验的结果也很好. 当然,也可以先用ada系列先跑,最后快收敛的时候,更换成sgd继续训练.同样也会有提升.据说adadelta一般在分类问题上效果比较好，adam在生成问题上效果比较好。(Captain Jack令言：sgd adam 这些选择上, 看你个人选择. 一般对网络不是决定性的. 反正我无脑用sgd + momentum. ）</p><p>5.<strong>激活函数</strong><br>    除了gate之类的地方,需要把输出限制成0-1之外,<strong>尽量不要用sigmoid</strong>,可以用tanh或者relu之类的激活函数.1. sigmoid函数在-4到4之外的区间梯度接近0，很容易造成梯度消失问题。2. 输入0均值，sigmoid函数的输出不是0均值的。（hzwer令言:虽然有至少十种激活函数，但在 Relu 外只推荐试一下 Swish。)</p><p>6.BN层具有加速训练速度，有效防止梯度消失与梯度爆炸，具有防止过拟合的效果，所以构建网络时最好要加上这个组件。(Captain Jack令言：batch normalization我一直没用, 虽然我知道这个很好, 我不用仅仅是因为我懒. 所以要鼓励使用batch normalization.）</p><p>7.如果你的模型包含全连接层（MLP），并且输入和输出大小一样，可以考虑将MLP替换成<strong>Highway Network</strong>,我尝试对结果有一点提升，建议作为最后提升模型的手段，原理很简单，就是给<strong>输出加了一个gate来控制信息的流动</strong>，详细介绍请参考论文: <a href="https://link.zhihu.com/?target=http://arxiv.org/abs/1505.00387">http://arxiv.org/abs/1505.00387</a></p><p>8.来自@张馨宇的技巧：<strong>一轮加正则，一轮不加正则，反复进行。</strong></p><p><strong>9.Ensemble</strong><br>Ensemble是论文刷结果的终极核武器,深度学习中一般有以下几种方式<br>同样的参数,不同的初始化方式<br>不同的参数,通过cross-validation,选取最好的几组<br>同样的参数,模型训练的不同阶段，即不同迭代次数的模型。<br>不同的模型,进行线性融合. 例如RNN和传统模型.</p><p><strong>10.自动调参方法</strong><br>（1）Grid Search：其原理就像是在数组里找最大值。缺点是太费时间了，特别像神经网络，一般尝试不了太多的参数组合。<br>（2）Random Search：经验上，Random Search比Gird Search更有效。实际操作的时候，一般也是先用Gird Search的方法，得到所有候选参数，然后每次从中随机选择进行训练。另外Random Search往往会和由粗到细的调参策略结合使用，即在效果比较好的参数附近进行更加精细的搜索。<br>（3）Bayesian Optimization：贝叶斯优化，考虑到了不同参数对应的 实验结果值，因此更节省时间，贝叶斯调参比Grid Search迭代次数少， 速度快；而且其针对非凸问题依然稳健。</p><p><strong>11.Loss设计</strong><br>+ 一般来说分类就是Softmax, 回归就是L2的loss. 但是要注意loss的错误范围(主要是回归), 你预测一个label是10000的值, 模型输出0, 你算算这loss多大, 这还是单变量的情况下. 一般结果都是nan. 所以不仅仅输入要做normalization, 输出也要.<br>+ 多任务情况下, 各loss想法限制在一个量级上, 或者最终限制在一个量级上, 初期可以着重一个任务的loss。</p><h3 id="网络结构设计（关于SE"><a href="#网络结构设计（关于SE" class="headerlink" title="网络结构设计（关于SE)"></a><strong>网络结构设计（关于SE)</strong></h3><p>SE在分类上是个涨点必备的工具，换言之，堆最高精度是一定要给每个block都加上它的，但是如果需要考虑时间，参数量和精度等的trade-off，无脑堆就没有意义了，这个时候应该要选择在合适的地方使用合适的模块。这个时候，<strong>推荐在block数量和添加SE上做权衡</strong>，即<strong>给部分blcok加上SE，同时砍掉一些block来加速</strong>，这样可以在精度差不多的情况下减少一些参数量。当然inference时间这个事需要看具体的应用平台对SE的实现，就是GAP和FC的速度，这就具体问题具体分析了。<strong>有余力有卡的人，可以迁移某种NAS方法来做这个的搜索。</strong><br>参考自：<br>你有哪些deep learning（rnn、cnn）调参的经验？ - 萧瑟的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/94816420">https://www.zhihu.com/question/41631631/answer/94816420</a><br>你有哪些deep learning（rnn、cnn）调参的经验？ - Towser的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/862075836">https://www.zhihu.com/question/41631631/answer/862075836</a><br>你有哪些deep learning（rnn、cnn）调参的经验？ - 罗浩.ZJU的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/216788968">https://www.zhihu.com/question/41631631/answer/216788968</a><br>你有哪些deep learning（rnn、cnn）调参的经验？ - 京东白条的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/776852832">https://www.zhihu.com/question/4163</a></p><blockquote><p>所谓SE：SENet是Squeeze-and-Excitation Networks的简称，拿到了ImageNet2017分类比赛冠军，其效果得到了认可，其提出的SE模块思想简单，易于实现，并且很容易可以加载到现有的网络模型框架中。*<u>SENet主要是学习了channel之间的相关性，筛选出了针对通道的注意力</u>*，稍微增加了一点计算量，但是效果比较好。</p></blockquote><p>对于CNN网络来说，其核心计算是卷积算子，其通过卷积核从输入特征图学习到新特征图。从本质上讲，卷积是对一个局部区域进行特征融合，这包括空间上（H和W维度）以及通道间（C维度）的特征融合。</p><p><img src="https://img-blog.csdnimg.cn/2019051415564658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pamlheWFuMTIz,size_16,color_FFFFFF,t_70"></p><p>卷积实际上是对<u>局部区域</u>进行的特征融合。 这也导致了普通卷积神经网络的感受野不大，当然你也可以设计出更多的通道特征来增加这个，但是这样做导致了计算量大大的增加。因此为了空间上融合更多特征融合，或者是提取多尺度空间信息。也提出了许多不同的方法如Inception网络的多分支结构。对于channel维度的特征融合，卷积操作基本上默认对输入特征图的所有channel进行融合。<u>而SENet网络的创新点在于关注channel之间的关系，希望模型可以自动学习到不同channel特征的重要程度</u>。为此，SENet提出了Squeeze-and-Excitation (SE)模块，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190514160215998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pamlheWFuMTIz,size_16,color_FFFFFF,t_70"></p><h3 id="反面训诫"><a href="#反面训诫" class="headerlink" title="反面训诫"></a>反面训诫</h3><p>1.1、一上来就自己动手写模型。<br>建议首先用<strong>成熟的开源项目及其默认配置</strong>（例如 Gluon 对经典模型的各种复现、各个著名模型作者自己放出来的代码仓库）在自己的数据集上跑一遍，在等程序运行结束的时间里仔细研究一下代码里的各种细节，最后再自己写或者改代码。</p><p>1.2、<strong>不推荐做人肉模型设计</strong>，比如把某层卷积改大一点，或者微调一下通道数。除非有特别 insight，不要自己乱设计新组件。</p><p>2、训 RNN 不加 gradient clipping，导致训练一段时间以后 loss 突然变成 Nan。</p><p>3、tying input &amp; output embedding（就是词向量层和输出 softmax 前的矩阵共享参数，在语言模型或机器翻译中常用）时学习率需要设置得非常小，不然容易 Nan。</p><p>4.1、在数据集很大的情况下，一上来就跑全量数据。建议先用 1/100、1/10 的数据跑一跑，对模型性能和训练时间有个底。</p><p>4.2认为网络层数越大越好。参数量什么的都不是大问题，在性能不丢的情况下，网络层数减到最小.（Captain Jack令言：你有95%概率不会使用超过40层的模型. ）</p><p>5、只喜欢漂亮的模型结构，瞧不起调参数的论文/实验报告，<strong>看论文时经常不看超参数设置等细节</strong>。殊不知在自己没有太多资源实验的情况下，实验报告类文章简直是业界良心！<br>NLP 领域主要推荐以下几篇：<br>Regularizing and Optimizing LSTM Language Models（LSTM 的训练技巧）<br>Massive Exploration of Neural Machine Translation Architectures（NMT 里各个超参的影响）<br>Training Tips for the Transformer Model（训练 Transformer 时会发生的各种现象）<br>RoBERTa: A Robustly Optimized BERT Pretraining Approach（BERT 预训练技巧，虽然跟大部分人没啥关系）<br>CV 我不算太熟，不过也可以勉强推荐几篇：</p><p><a href="https://arxiv.org/pdf/1706.02677.pdf">Training ImageNet in 1 Hour（大批量训练技巧）</a><br><a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.pdf">Bag of Tricks for Image Classification with Convolutional Neural Networks（各种训练技巧集大成）</a><br><a href="https://arxiv.org/pdf/1905.11946.pdf">EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks（当前对参数利用最有效的 CNN）</a></p><p>6、对于loss这种受 batch size、sequence length 各种因素影响的数字，人是没有数感的，建议首先计算一下 per token loss（如果是多任务，可以每个任务单独算；类似地，某些 CV 任务可以计算 per pixel loss），心里有点感觉。<strong>脱离损失函数的形式谈学习率没有意义</strong>（例如单是对 batch size 求和或者取平均这个差异就会使梯度差成百上千倍）。<br>在确定初始学习率的时候，从一个很小的值（例如 1e-7）开始，然后<strong>每一步指数增大学习率（例如扩大1.05 倍）进行训练。</strong>训练几百步应该能观察到损失函数随训练步数呈对勾形，选择损失下降最快那一段的学习率即可。<br>(Captain Jack令言：<strong>观察loss胜于观察准确率</strong><br>准确率虽然是评测指标, 但是训练过程中还是要注意loss的. 你会发现有些情况下, 准确率是突变的, 原来一直是0, 可能保持上千迭代, 然后突然变1. 要是因为这个你提前中断训练了, 只有老天替你惋惜了. 而loss是不会有这么诡异的情况发生的, 毕竟优化目标是loss.<br>给NN一点时间, 要根据任务留给NN的学习一定空间. 不能说前面一段时间没起色就不管了. 有些情况下就是前面一段时间看不出起色, 然后开始稳定学习.）</p><p>7.1、优化器<strong>只推荐</strong> Momentum 和 Adam。在这些方面做尝试意义不大，如果性能提升反倒可能说明模型不成熟。</p><p>7.2、<strong>Adam 可以解决一堆奇奇怪怪的问题</strong>（有时 loss 降不下去，换 Adam 瞬间就好了），<strong>也可以带来一堆奇奇怪怪的问题</strong>（比如单词词频差异很大，当前 batch 没有的单词的词向量也被更新；再比如Adam和L2正则结合产生的复杂效果）。用的时候要胆大心细，万一遇到问题找各种魔改 Adam（比如 <a href="https://www.zhihu.com/question/265357659/answer/580469438">MaskedAdam</a>, AdamW 啥的）抢救。</p><p>8、subword 总是会很稳定地涨点，只管用就对了。</p><p>9、<strong>GPU 上报错时尽量放在 CPU 上重跑</strong>，错误信息更友好。例如 “ERROR:tensorflow:Model diverged with loss = NaN” 其实很有可能是输入 ID 超出了 softmax 词表的范围。</p><p><strong>10、别没耐心</strong>！<br><strong>有些指标是有滞后性的，需要等训练一段时间才开始动。</strong>很多人训练几步看没什么效果就把程序停掉开始 debug 了，但其实代码毫无问题。如此反复好几天甚至一两周都在原地踏步，其实需要做的仅仅是让程序自个儿安安静静地跑上几个小时或者一天……</p><h3 id="相关trick"><a href="#相关trick" class="headerlink" title="相关trick"></a>相关trick</h3><ul><li><p> fine-tuning: 通常来说，直接把预训练模型来用效果不一定足够好，因此需要进行fine-tuning（微调）。fine-tuning需要冻结网络的前几层参数，只更新网络结构的后面几层和最后的全连接层，这样效果会更好。</p></li><li><p>  Learning rate:在迁移学习的微调过程中一般不建议使用过大的学习率，通常来说1e-5是比较合适的选择。</p></li></ul><h4 id="迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。"><a href="#迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。" class="headerlink" title="迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。"></a>迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。</h4><ul><li><h5 id="新的数据集较小，并且和pre-trained-model所使用的训练数据集相似度较高"><a href="#新的数据集较小，并且和pre-trained-model所使用的训练数据集相似度较高" class="headerlink" title="新的数据集较小，并且和pre-trained model所使用的训练数据集相似度较高"></a>新的数据集较小，并且和pre-trained model所使用的训练数据集相似度较高</h5><p>由于数据集较小，在进行finetune存在overfit的风险，又由于数据集和原始数据集相似度较高，因此二者不论是local feature还是global feature都比较相   近，所以此时最佳的方法是把CNN网络当做特征提取器然后训练一个分类器进行分类  </p></li><li><h5 id="新的数据集较大，并且和pre-trained-model所使用的训练数据集相似度较高："><a href="#新的数据集较大，并且和pre-trained-model所使用的训练数据集相似度较高：" class="headerlink" title="新的数据集较大，并且和pre-trained model所使用的训练数据集相似度较高："></a>新的数据集较大，并且和pre-trained model所使用的训练数据集相似度较高：</h5><p>很明显，此时我们不用担心overfit，因此对全部网络结构进行fine-tune是较好的。</p></li><li><h5 id="新的数据集较小，并且和pre-trained-model所使用的训练数据集差异很大："><a href="#新的数据集较小，并且和pre-trained-model所使用的训练数据集差异很大：" class="headerlink" title="新的数据集较小，并且和pre-trained model所使用的训练数据集差异很大："></a>新的数据集较小，并且和pre-trained model所使用的训练数据集差异很大：</h5><p>由于数据集较小，不适合进行fine-tune，由于数据集差异大，应该在单独训练网络结构中较高的层，前面几层local的就不用训练了，直接固定权值。在实际中，这种问题下较好的解决方案一般是从网络的某层开始取出特征，然后训练SVM分类器。 </p></li><li><h5 id="新的数据集较大，并且和pre-trained-model所使用的训练数据集差异很大："><a href="#新的数据集较大，并且和pre-trained-model所使用的训练数据集差异很大：" class="headerlink" title="新的数据集较大，并且和pre-trained model所使用的训练数据集差异很大："></a>新的数据集较大，并且和pre-trained model所使用的训练数据集差异很大：</h5><p>本来由于数据集较大，可以从头开始训练的，但是在实际中更偏向于训练整个pre-trained model的网络。</p></li></ul><p>  ​    </p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>微调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梯度裁剪</title>
    <link href="/2021/08/12/deep_learning/gradient-clip/"/>
    <url>/2021/08/12/deep_learning/gradient-clip/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读代码 optimizer_config = dict(grad_clip=dict(max_norm=35, norm_type=2))，就此探究一下grap_clip。他的作用是梯度裁剪，为了防止梯度爆炸。其中max_norm是最大梯度阈值，norm_type是指定的范数类型。</p></blockquote><h2 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h2><p>梯度爆炸就是在梯度更新的时候偏导数很大，导致更新参数无法收敛到最值（总是跳到其他不好的地方）。</p><p>$$<br>w_1=w_1− \alpha \frac{∂J(w)}{∂w1}<br>$$</p><p>$$<br>w_2=w_2− \alpha \frac{∂J(w)}{∂w2}<br>$$</p><p><img src="https://img-blog.csdn.net/20180313201807699?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2d1b2xpbmRvbmdnbGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><p>这里介绍梯度裁剪（Gradient Clipping）的方法，对梯度进行裁剪，论文提出对梯度的L2范数进行裁剪，也就是所有参数偏导数的平方和再开方。</p><p>$$<br>g_1=\frac{∂J(w)}{∂w1}<br>$$</p><p>$$<br>g_2=\frac{∂J(w)}{∂w2}<br>$$</p><p>设定裁剪阈值为 C = max_norm，$\Vert g\Vert_2= \sqrt{g^2_1+g^2_2}$</p><p>当$\Vert g\Vert_2$大于c时：</p><p>$$<br>g = \frac{c}{\Vert g \Vert_2} \cdot g<br>$$<br>当$\Vert g\Vert_2$小于等于C时：g不变。其中，$\frac{c}{\Vert g \Vert_2}$是一个标量</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>训练模型出现Loss值出现跳动，一直不收敛时，除了设小学习率之外，梯度裁剪也是一个好方法。</p><p>然而效果不佳时，那这就跟学习率和梯度爆炸没啥关系了。因此，<strong>学习率</strong>的设定和<strong>梯度裁剪</strong>的阈值并不能提高模型的准确率</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习，梯度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer05 替换空格</title>
    <link href="/2021/08/11/leetcode/leetcode-offer05/"/>
    <url>/2021/08/11/leetcode/leetcode-offer05/</url>
    
    <content type="html"><![CDATA[<blockquote><p>替换空格</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">"We are happy."</span><br>输出：<span class="hljs-string">"We%20are%20happy."</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>0 &lt;= s 的长度 &lt;= 10000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接替换即可。相当于使用replace方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>       <span class="hljs-comment">#相当于现成函数 return s.replace(" ","%20")</span><br>        result = <span class="hljs-string">""</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x==<span class="hljs-string">' '</span>:<br>                x = <span class="hljs-string">"%20"</span><br>            result += x<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer04 二维数组中的查找</title>
    <link href="/2021/08/11/leetcode/leetcode-offer04/"/>
    <url>/2021/08/11/leetcode/leetcode-offer04/</url>
    
    <content type="html"><![CDATA[<blockquote><p>二维数组中的查找</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><p>现有矩阵 matrix 如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>],<br>  [<span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>],<br>  [<span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>],<br>  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span>],<br>  [<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span>]<br>]<br></code></pre></td></tr></tbody></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>0 &lt;= n &lt;= 1000</li><li>0 &lt;= m &lt;= 1000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>当开始想要采用二分法的思想进行判断。但是发现二分只能考虑到左上和右下块的内容。右上和左下的内容无法判断其大小划分。所以会有视觉盲区无法二分缩小区域。</p><p><font color="purple">二维数组无法用二分法，因为其“二分”是分为4份，无法充分涵盖进行判断，会出现错误。</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberIn2DArray</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(matrix): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        si,sj = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        ei,ej = <span class="hljs-built_in">len</span>(matrix)-<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isExit</span>(<span class="hljs-params">matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], si, sj, ei, ej, target: <span class="hljs-built_in">int</span></span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (si&lt;=ei <span class="hljs-keyword">and</span> sj&lt;=ej): <span class="hljs-comment">#先判断范围</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span>(target&lt;matrix[si][sj] <span class="hljs-keyword">or</span> target&gt;matrix[ei][ej]): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span>(target==matrix[si][sj] <span class="hljs-keyword">or</span> target==matrix[ei][ej]): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            mi,mj = <span class="hljs-built_in">int</span>((si+ei)/<span class="hljs-number">2</span>),<span class="hljs-built_in">int</span>((sj+ej)/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(target==matrix[mi][mj]):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> (target&gt;matrix[mi][mj]):<br>                <span class="hljs-keyword">return</span> isExit(matrix,mi+<span class="hljs-number">1</span>,mj,ei,ej,target) <span class="hljs-keyword">or</span> isExit(matrix,mi,mj+<span class="hljs-number">1</span>,ei,ej,target)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> isExit(matrix,si,sj,mi-<span class="hljs-number">1</span>,mj,target) <span class="hljs-keyword">or</span> isExit(matrix,si,sj,mi,mj-<span class="hljs-number">1</span>,target)<br>        <span class="hljs-keyword">return</span> isExit(matrix,si,sj,ei,ej,target)<br></code></pre></td></tr></tbody></table></figure><p>使用线性查找的方法，可以使得复杂度从暴力的O(n*m)到O(n+m)<br>思想是选取左下角或者右上角，周围不均衡的点开始进行判断，这样才知道应该向哪个方向缩小区域.</p><p><font color="hotpink">例如此处是选取左下角作为初始，向上此列逐渐变小，向右此行逐渐变大。因此target如果比此点小，就向上移动查找，如果比此点大，就向右查找。</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberIn2DArray</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(matrix): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        i,j = <span class="hljs-built_in">len</span>(matrix)-<span class="hljs-number">1</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j&lt;=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span>(target==matrix[i][j]):<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span>(target&gt;matrix[i][j]):j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:i -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>idea</tag>
      
      <tag>数组查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer03 数组中重复的数字</title>
    <link href="/2021/08/11/leetcode/leetcode-offer03/"/>
    <url>/2021/08/11/leetcode/leetcode-offer03/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数组中重复的数字</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>2 &lt;= n &lt;= 100000</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>创建一个flag数组进行标记；</p><p>指定大小的数组创建</p><ul><li><p>一维</p><p>a = [0 for _ in range(n)]  《=》  a = [0] * n </p></li><li><p>二维</p><p>a = [[0 for col in range(m)] for row in range(n)]  <em># 创建一个n*m的二维矩阵a，每个初值都是0</em>   《=》  a = [[0] *m] *n </p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRepeatNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        flag = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))] <span class="hljs-comment">#创建长度为nums的数组 也可以用[0]*n</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            flag[x] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(flag[x]&gt;<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></tbody></table></figure><p><font color="purple" size="4">实际上无需构建新的数组进行标记，可以直接使用set的长度进行判断。或者使用sort，使用list的sort方法。判断相邻的元素是否相等。</font></p><p>方法1：利用python set的无序不重复特性：利用Python中的set集合为无序不重复集合，通过判断temp_set的长度确定是否是重复数字。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRepeatNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        temp_set = <span class="hljs-built_in">set</span>()<br>        repeat = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            temp_set.add(nums[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp_set) &lt; i + <span class="hljs-number">1</span>:<br>                repeat = nums[i]<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> repeat<br></code></pre></td></tr></tbody></table></figure><p>方法2：利用python的sort函数排序，然后计算相邻两个数据是否相等即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRepeatNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i]==nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> nums[i]<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>数组</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dvc相关设置</title>
    <link href="/2021/08/10/dvc/dvc-config/"/>
    <url>/2021/08/10/dvc/dvc-config/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><p>运行 sh setup.sh detection报错：</p><blockquote><p>(base) root@9b1a4b217508:/workspace/fanmeilin/project/task/ai_lab# sh setup.sh detection<br>setup.sh: 12: setup.sh: dvc: not found<br>cp: failed to get attributes of ‘assets/examples’: No such file or directory<br>[*] copy DETECTION skeleton scripts to upper directory</p></blockquote><p>原因是未安装dvc，运行下面的命令安装dvc</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install dvc==<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pip</span> install 'dvc[s<span class="hljs-number">3</span>]'<br></code></pre></td></tr></tbody></table></figure><blockquote><p>在Win平台下可能会报错：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>Cannot uninstall 'ruamel-yaml'. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.<br></code></pre></td></tr></tbody></table></figure><p>此时需要进入python 的lib/site-packages 中删除 ‘ruamel-yaml’ 相关的文件</p></blockquote><p><strong>注意：</strong> dvc 2.3.0 版本与之后的hash计算方法不同，不能混用</p><p>再次执行 sh setup.sh detection报错</p><blockquote><p>ERROR: unexpected error - Cannot connect to host ceph01:80 ssl:default [Name or service not known]: [Errno -2] Name or service not known  </p></blockquote><p>则修改etc/hosts文件</p><ul><li>配置hosts文件，在hosts文件中增加以下内容<br><code>192.168.10.91 ceph01</code></li></ul><h5 id="详细dvc的各种操作，可移步-师兄博客-DVC-使用手册"><a href="#详细dvc的各种操作，可移步-师兄博客-DVC-使用手册" class="headerlink" title="详细dvc的各种操作，可移步 师兄博客 DVC 使用手册"></a><em>详细dvc的各种操作，可移步</em> <a href="https://www.zywvvd.com/2020/12/17/dvc/dvc/">师兄博客 DVC 使用手册</a></h5>]]></content>
    
    
    <categories>
      
      <category>dvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker的ssh相关配置</title>
    <link href="/2021/08/10/docker/docker-ssh/"/>
    <url>/2021/08/10/docker/docker-ssh/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考师兄博客：<a href="https://www.zywvvd.com/2020/11/02/windows/win_ssh_linux_docker/win_ssh_linux_docker/">https://www.zywvvd.com/2020/11/02/windows/win_ssh_linux_docker/win_ssh_linux_docker/</a></p></blockquote><blockquote><p>ssh是较可靠，专为远程登录会话和其他网络服务提供安全性的协议，广泛用于远程登录的场景，也是远程调试代码的神兵利器。在开发中经常会在服务器启动自己的 docker 容器进行开发，又需要调试代码，vim的调试环境配置起来门槛又太高。于是就有了使用Windows直接ssh打通docker进行调试的需求。本文记录Windows远程登录Linux服务器docker容器的方法。</p></blockquote><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><ul><li>登录主机操作系统 Win 10</li><li>被登录主机操作系统 docker container in Linux</li><li>主机与被登录主机（此处指服务器，不是docker）网络联通，IP在同一网段</li><li>服务器与docker的IP在同一网段</li></ul><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><h3 id="建立docker与Linux服务器的端口映射"><a href="#建立docker与Linux服务器的端口映射" class="headerlink" title="建立docker与Linux服务器的端口映射"></a>建立docker与Linux服务器的端口映射</h3><blockquote><p>ssh协议链接时默认使用22端口，Windows与docker的端口往往不能直接进行映射（很可能不在一个网段），因此需要将docker的22端口映射到Linux服务器的某个端口，此时需要在建立docker容器时进行<a href="https://www.zywvvd.com/2020/05/14/coding/environment/wingide-remote-docker/wingide-remote-docker/#docker%E9%85%8D%E7%BD%AE">配置</a>：</p></blockquote><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker run -it --name vvd -p <span class="hljs-number">3721</span>:<span class="hljs-number">22</span> -v <span class="hljs-regexp">/root/</span>tmp:<span class="hljs-regexp">/root/</span>tmp my_docker bash<br></code></pre></td></tr></tbody></table></figure><ul><li>其中 <code>-p</code> 的部分表示将本机（服务器）的3721端口映射到容器的22端口。</li></ul><h3 id="容器内部安装ssh服务"><a href="#容器内部安装ssh服务" class="headerlink" title="容器内部安装ssh服务"></a>容器内部安装ssh服务</h3><blockquote><p>需要在被登录的容器内部建立并启动ssh服务。</p></blockquote><ul><li>首先需要安装：</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> update<br>apt-<span class="hljs-builtin-name">get</span> install openssh-server<br>apt-<span class="hljs-builtin-name">get</span> install openssh-client<br></code></pre></td></tr></tbody></table></figure><ul><li>安装完成后需要容器每次启动时自动运行相关服务，可以在 <code>~/.bashrc</code>中加入：</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/ssh start<br></code></pre></td></tr></tbody></table></figure><blockquote><p>这样就保证了docker容器自动启动该服务。</p></blockquote><ul><li>查看ssh运行状态</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/ssh status<br></code></pre></td></tr></tbody></table></figure><blockquote><p>如果是 <code>* sshd is running</code> 说明ssh正常运行</p></blockquote><h3 id="修改容器内root用户登录设置"><a href="#修改容器内root用户登录设置" class="headerlink" title="修改容器内root用户登录设置"></a>修改容器内root用户登录设置</h3><blockquote><p>有的容器默认不支持root用户远程使用ssh协议进行密码登录的，此时需要更改设置。</p></blockquote><ul><li>打开 <code>/etc/ssh/sshd_config</code>文件：</li></ul><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># PermitRootLogin prohibit-password # 默认打开 禁止root用户使用密码登陆，需要将其注释</span><br><span class="hljs-attribute">RSAAuthentication</span> <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用 RSA 认证</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用公钥私钥配对认证方式</span><br>PermitRootLogin <span class="hljs-literal">yes</span> <span class="hljs-comment">#允许root用户使用ssh登录</span><br></code></pre></td></tr></tbody></table></figure><ul><li>将 <code>PermitRootLogin</code> 设置为 yes</li></ul><h3 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h3><blockquote><p>远程登录时需要使用系统的用户密码，我们就直接使用root用户登录好了，需要设置新建容器的密码：</p></blockquote><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd root</span><br></code></pre></td></tr></tbody></table></figure><h3 id="设置SSH"><a href="#设置SSH" class="headerlink" title="设置SSH"></a>设置SSH</h3><ul><li><a href="https://www.zywvvd.com/2020/02/23/git/link_github/Git-connect-remote-pos/#%E5%88%9B%E5%BB%BASSH%E5%AF%86%E9%92%A5">本地生成ssh key</a></li><li>将.pub 内容复制粘贴加入到远程 ~/.ssh/authorized_keys</li></ul><h3 id="SSH连接服务器"><a href="#SSH连接服务器" class="headerlink" title="SSH连接服务器"></a>SSH连接服务器</h3><blockquote><p>需要用户名（被登录端用户）与被登录的主机ip和端口号</p><p>例如： 用户名- root ip：192.168.10.12 端口映射为 3721</p></blockquote><ul><li>linux</li></ul><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> root@<span class="hljs-number">192.168.10.12:3721</span><br></code></pre></td></tr></tbody></table></figure><ul><li>Windows</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> -p <span class="hljs-number">3721</span> root@<span class="hljs-number">192.168.10.12</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200256.png" alt="img"></p><ul><li>如果不清楚Linux系统端口映射配置情况：</li></ul><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">iptables -<span class="hljs-built_in">t</span> nat -L -<span class="hljs-built_in">n</span><br></code></pre></td></tr></tbody></table></figure><h3 id="X-shell配置"><a href="#X-shell配置" class="headerlink" title="X-shell配置"></a>X-shell配置</h3><blockquote><p>命令行ssh登录成功后就可以在X-shell中建立配置信息方便地连接了。</p></blockquote><ul><li>新建会话，填写名称、IP、端口号（我们刚刚配置过的）：</li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200522.png" alt="img"></p><ul><li>用户身份认证，填入用户名密码（刚刚配置过的）：</li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200640.png" alt="img"></p><ul><li>随后就可以使用该会话直接登录docker容器了，为远程调试打下了坚实的基础：</li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200804.png" alt="img"></p><h3 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h3><ul><li><p>ssh: Could not resolve hostname 192.168.10.12:3721: Name or service not known</p><blockquote><p>这是在Windows中使用了Linux格式的SSH登录命令导致的解析错误</p><p>将命令语法更换为Windows的格式即可</p></blockquote></li><li><p>root 用户无论如何密码不被接受</p><blockquote><p>需要在被登录主机 /etc/ssh/sshd_config 中设置：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># PermitRootLogin prohibit-password # 默认打开 禁止root用户使用密码登陆，需要将其注释</span><br><span class="hljs-attribute">RSAAuthentication</span> <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用 RSA 认证</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用公钥私钥配对认证方式</span><br>PermitRootLogin <span class="hljs-literal">yes</span> <span class="hljs-comment">#允许root用户使用ssh登录</span><br></code></pre></td></tr></tbody></table></figure><ul><li>重点：<strong>PermitRootLogin yes</strong></li></ul></blockquote></li><li><p>Connection to 192.168.10.12 closed.</p></li><li><p>或</p></li><li><p>Connection closed by foreign host.</p><blockquote><p>意思是 断开主机链接了，出现这种问题，跟你的IPTABLES，防火墙什么的都没关系。</p><p>造成这个原 因是因为原来连接到SSHD服务器进程的22端口，当你的客户端突然断开时，服务器端的TCP连接就处于一个半打开状态。当下一次同一客户机再次建立 TCP连接时，服务器检测到这个半打开的TCP连接，并向客户机回传一个置位RST的TCP报文，客户机就会显示connection closed by foreign host。<br>这是TCP协议本身的一个保护措施，并不是什么错误，你只要再重新连接服务器就能连上。</p><p>——— <a href="http://www.pooy.net/connection-closed-foreign-host.html">http://www.pooy.net/connection-closed-foreign-host.html</a></p><p>总结一下解决方案： <strong>关机重启</strong></p></blockquote></li></ul><h3 id="关于ssh的相关配置"><a href="#关于ssh的相关配置" class="headerlink" title="关于ssh的相关配置"></a>关于ssh的相关配置</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>ssh<br>vi ssh_config <span class="hljs-comment">#可设置ssh的默认端口（22）</span><br>vi sshd_config<br></code></pre></td></tr></tbody></table></figure><p>ssh_config和sshd_config都是ssh服务器的配置文件，二者区别在于，前者是针对客户端的配置文件，后者则是针对服务端的配置文件。两个配置文件都允许你通过设置不同的选项来改变客户端程序的运行方式。</p><h4 id="重启ssh服务"><a href="#重启ssh服务" class="headerlink" title="重启ssh服务"></a>重启ssh服务</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service sshd restart</span><br></code></pre></td></tr></tbody></table></figure><p>如果报错 sshd: unrecognized service 则需要开启ssh服务。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/ssh start<br></code></pre></td></tr></tbody></table></figure><h2 id="vscode连接远程服务器"><a href="#vscode连接远程服务器" class="headerlink" title="vscode连接远程服务器"></a>vscode连接远程服务器</h2><ul><li><p>正确的ssh服务</p></li><li><p>密码设置完成（passwd root）</p></li></ul><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><ul><li><p>安装 Remote Development 插件</p><blockquote><p>会自动安装 Remote-WSL / Containers / SSH 等插件。</p></blockquote></li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028143530.png" alt="img"></p><h3 id="配置主机信息"><a href="#配置主机信息" class="headerlink" title="配置主机信息"></a>配置主机信息</h3><blockquote><p>ctrl + shift + p</p></blockquote><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028174129.png" alt="img"></p><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028175152.png" alt="img"></p><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host Enter<br>  HostName <span class="hljs-number">192.168</span>.<span class="hljs-number">10.15</span><br>  Port <span class="hljs-number">12345</span><br>  <span class="hljs-keyword">User</span> <span class="hljs-title">root</span><br>  IdentityFile ~\.ssh\id_rsa<br>  IdentitiesOnly yes<br></code></pre></td></tr></tbody></table></figure><h3 id="vs-code-连接远程主机"><a href="#vs-code-连接远程主机" class="headerlink" title="vs code 连接远程主机"></a>vs code 连接远程主机</h3><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028175324.png" alt="img"></p><blockquote><p>之后选择目标主机的操作系统。</p></blockquote><ul><li><p>成功连接到远程主机：</p></li><li><p>打开文件夹运行程序时，选择使用的Python环境：</p></li></ul><h4 id="相对路径的设置"><a href="#相对路径的设置" class="headerlink" title="相对路径的设置"></a>相对路径的设置</h4><p>在读取文件时，可能使用相对路径出现错误。</p><blockquote><p>python 插件设置中没有设置<code>终端执行命令时使用文件的路径代替现在打开的目录</code>。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>搜索配置 <code>execute in file</code>：</li></ul><p><img src="https://photos.zywvvd.com/win11-mt/20210717114300.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>远程配置</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker相关命令</title>
    <link href="/2021/08/10/docker/docker-intro/"/>
    <url>/2021/08/10/docker/docker-intro/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简要介绍Docker，记录Docker常用命令使用方法。</p><p>搬运自师兄的博客 又见苍岚 ：<a href="https://www.zywvvd.com/2020/05/06/docker/docker_usage/">https://www.zywvvd.com/2020/05/06/docker/docker_usage/</a></p></blockquote><h3 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h3><blockquote><p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p></blockquote><h3 id="Docker-使用流程"><a href="#Docker-使用流程" class="headerlink" title="Docker 使用流程"></a>Docker 使用流程</h3><ul><li><a href="https://docs.docker.com/desktop/">安装docker</a></li><li>创建Image</li><li>从Image创建Container</li><li>在Container中工作</li><li>将在Container中做的修改提交给Image</li><li>销毁Container</li></ul><h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><ul><li>拉取 image</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> image pull<span class="hljs-meta"> [docker-url]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>获取docker images 列表</li></ul><figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker images<br>或<br>docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span><br></code></pre></td></tr></tbody></table></figure><ul><li>建立container （nvidia docker)</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">NV_GPU=<span class="hljs-selector-attr">[gpu_num]</span> nvidia-docker run -it --name <span class="hljs-selector-attr">[container_name]</span> --shm-size=<span class="hljs-selector-attr">[shm_size]</span> --rm -v <span class="hljs-selector-attr">[current_dir]</span>:<span class="hljs-selector-attr">[container_dir]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[current_port]</span>:<span class="hljs-selector-attr">[container_port]</span> <span class="hljs-selector-attr">[image_name]</span>:<span class="hljs-selector-attr">[image_tag]</span>  <span class="hljs-selector-attr">[command]</span> <br></code></pre></td></tr></tbody></table></figure><p>实例：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvidia</span>-docker run -it --name mlfan --shm-size=<span class="hljs-number">10</span>g -v /disk/fanmeilin:/workspace/fanmeilin -p <span class="hljs-number">12345</span>:<span class="hljs-number">22</span> -p <span class="hljs-number">12346</span>:<span class="hljs-number">8080</span> -p <span class="hljs-number">12347</span>:<span class="hljs-number">5678</span> tf-<span class="hljs-number">1</span>.<span class="hljs-number">14</span>-<span class="hljs-number">2</span>.<span class="hljs-number">0</span>-<span class="hljs-number">2</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> bash<br></code></pre></td></tr></tbody></table></figure><p><font color="SlateBlue" size="4">注意不要加 –rm&nbsp; 否则载在container stop之后会自动删除此容器</font></p><blockquote><p>NV_GPU: container中可见的GPU，如果不设置可见所有GPU</p><p>-it: 将容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</p><p>–name: 容器名称，如果不设置会随机分配一个名字</p><p>–shm-size: 容器共享内存大小设置。如果不设置默认大小64M，对于需要使用共享内存的情况往往是不够用的，如果设置为10g，这样配置： <code>--ssh-size="10g"</code></p><p>–rm: 容器关闭后自动删除，如果不设置容器不会自动删除</p><p>-v: 驱动器映射，将本机的目录映射到容器的指定文件夹中；需要说明的是，在主机文件夹中的挂载目录在容器中是可见的；需要再说明的是容器启动时主机挂载的目录容器是见不到的；最后说明，容器关闭再打开就可以看到主机挂载的所有文件夹了。</p><p>-p: 暴漏容器的端口到本机的端口上，例如用于ssh连接容器时需要将容器的22端口暴露到主机的端口上(比如3721)，则可以设置 <code>-p 3721:22</code></p><p>image_name, image_tag: 这是docker镜像的名称与标记，如果使用本机镜像可以在docker images列表中查询到</p><p>command: 启动容器后内部执行的第一个命令，一般为 <code>/bin/bash</code></p></blockquote><ul><li>查询container列表</li></ul><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker container <span class="hljs-keyword">ls</span> <span class="hljs-params">--all</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>–all: 加上该参数会显示没有在运行的容器，不加的话仅显示运行中的容器</p></blockquote><ul><li>停止指定的容器运行</li></ul><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> kill <span class="hljs-comment">[containerID]</span><br>docker stop <span class="hljs-comment">[containerID]</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。<code>docker container stop</code>命令相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p></blockquote><ul><li>启动停止的容器</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> start<span class="hljs-meta"> [containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>重启运行的容器</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart<span class="hljs-meta"> [containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>删除指定的容器文件（仅在停止运行时可用）</li></ul><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> rm <span class="hljs-comment">[containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>查看容器输出</li></ul><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> logs <span class="hljs-comment">[containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>启动容器的一个终端</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it [containerID] <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></tbody></table></figure><blockquote><p>此种方法启动的终端，即使退出也不会关闭容器</p><p>相反 - 如果直接通过端口映射连接 docker 建立的ssh链接，窗口退出后该终端的工作也会一同停止</p></blockquote><ul><li>进入容器的主终端</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> attach<span class="hljs-meta"> [containerID]</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>连接到容器的主终端，该终端退出后容器关闭。</p><p>如果不希望退出后关闭，可以加入选项 <code>--sig-proxy=false</code></p></blockquote><ul><li>退出终端</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ctrl <span class="hljs-selector-tag">p</span> + ctrl <span class="hljs-selector-tag">q</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>可以在退出终端的同时保持终端继续工作</p></blockquote><ul><li>退出容器</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>在容器中运行此命令</p></blockquote><ul><li>拷贝容器里的文件到本机</li></ul><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker container cp [containerID]:[<span class="hljs-regexp">/path/</span>to/<span class="hljs-keyword">file</span>]<br></code></pre></td></tr></tbody></table></figure><ul><li>提交容器修改到镜像</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker commit -<span class="hljs-selector-tag">a</span> <span class="hljs-selector-attr">[name]</span> -m <span class="hljs-selector-attr">[comments]</span> -<span class="hljs-selector-tag">p</span>  <span class="hljs-selector-attr">[containerID[:TAG]</span>]<br></code></pre></td></tr></tbody></table></figure><blockquote><p>-a: 提交的镜像作者</p><p>-m: 提交时的说明文字</p><p>-p: 在commit时，将容器暂停</p></blockquote><ul><li>删除镜像</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [image]</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>或</p></blockquote><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image rm [image]<br></code></pre></td></tr></tbody></table></figure><blockquote><p>支持的子命令如下：</p></blockquote><ul><li><code>-f, -force</code>: 强制删除镜像，即便有容器引用该镜像；</li><li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>远程配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer10-2 青蛙跳台阶问题</title>
    <link href="/2021/08/10/leetcode/leetcode-offer10-2/"/>
    <url>/2021/08/10/leetcode/leetcode-offer10-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>青蛙跳台阶问题</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">21</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>0 &lt;= n &lt;= 100</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>实际上是斐波那契数列的变种。跳上n级台阶的方法个数 可以分解为：<em>跳上此台阶前的一步是1步还是2步</em>。也就是 $f(n) = f(n-1) + f(n-2)$。</p><p>不同之处在于此时的f(0) = 1</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numWays</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        a,b = <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            a,b = b,a+b<br>        <span class="hljs-keyword">return</span> a%<span class="hljs-number">1000000007</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>idea</tag>
      
      <tag>斐波那契</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer10-1 斐波那契数列</title>
    <link href="/2021/08/10/leetcode/leetcode-offer10-1/"/>
    <url>/2021/08/10/leetcode/leetcode-offer10-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>斐波那契数列</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>$$<br>F(0) = 0,   F(1) = 1 \\<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>$$<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>0 &lt;= n &lt;= 100</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有三种方向：</p><ul><li><p>使用递归</p><p>大量重复计算，时间超时。</p></li><li><p>使用数组存储</p><p>新建长度为n的数组，在递归基础上，存储计算的结果，后直接取用。但是占用了额外的空间$O(n)$</p></li><li><p>使用动态规划</p><p><code>以其公式F(N) = F(N - 1) + F(N - 2)为转移方程。</code></p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        a,b = <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            a,b = b,a+b <span class="hljs-comment">#sum = a+b a = b b = sum a相当于f(i) b相当于f(i+1)</span><br>        <span class="hljs-keyword">return</span> a%<span class="hljs-number">1000000007</span><br>    <span class="hljs-comment"># def fib(self, n: int) -&gt; int:</span><br>    <span class="hljs-comment">#     if(n==0): return 0</span><br>    <span class="hljs-comment">#     if(n==1): return 1</span><br>    <span class="hljs-comment">#     return (self.fib(n-1)+self.fib(n-2))%1000000007 #超时 递归时间复杂度大</span><br></code></pre></td></tr></tbody></table></figure><p>循环n次</p><p>注意<code>a,b = b,a+b</code> 相当于sum = a+b ；a = b； b = sum ；</p><p>第i轮中 a相当于f(i)，b相当于f(i+1) 。因此最后返回a</p>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>斐波那契</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer09 用两个栈实现队列</title>
    <link href="/2021/08/10/leetcode/leetcode-offer09/"/>
    <url>/2021/08/10/leetcode/leetcode-offer09/</url>
    
    <content type="html"><![CDATA[<blockquote><p>用两个栈实现队列</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">"CQueue"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"deleteHead"</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">"CQueue"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"deleteHead"</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul><li>1 &lt;= values &lt;= 10000</li><li>最多会对 appendTail、deleteHead 进行 10000 次调用</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用两个栈，<em>一个作为插入栈，一个作为删除栈</em>。<code>使用list进行相关操作（append，pop）</code>；在插入时直接对stack1进行append操作，删除时首先需要构建删除栈内容，再进行判断，最后同步到插入栈中（此时删除栈又为空）。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># stack1是insert栈 stack2是delete栈</span><br>        self.stack1 = [] <span class="hljs-comment">#list作用和stack类似</span><br>        self.stack2 = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">appendTail</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self.stack1.append(value) <span class="hljs-comment"># 直接插入栈顶</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteHead</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">while</span> self.stack1: <span class="hljs-comment">#首先更新delete栈</span><br>            self.stack2.append(self.stack1.pop())<br>        <span class="hljs-comment">#进行deleteHead操作</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack2: <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        popitem = self.stack2.pop()<br>        <span class="hljs-comment"># 将更新结果写回stack1中 保持一致</span><br>        <span class="hljs-keyword">while</span> self.stack2:<br>            self.stack1.append(self.stack2.pop())<br>        <span class="hljs-keyword">return</span> popitem<br><br><span class="hljs-comment"># Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = CQueue()</span><br><span class="hljs-comment"># obj.appendTail(value)</span><br><span class="hljs-comment"># param_2 = obj.deleteHead()</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>剑指</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mahalanobis_distance</title>
    <link href="/2021/08/09/math/Mahalanobis-distance/"/>
    <url>/2021/08/09/math/Mahalanobis-distance/</url>
    
    <content type="html"><![CDATA[<blockquote><p>马氏距离(Mahalanobis Distance)是度量学习中一种常用的距离指标，同欧氏距离、曼哈顿距离、汉明距离等一样被用作评定数据之间的相似度指标。但却可以应对高维线性分布的数据中各维度间非独立同分布的问题。</p></blockquote><p><em>使用马氏距离，对高维非独立分布的数据进行距离度量。</em></p><p><strong>那我们为什么要用马氏距离呢？</strong><br>马氏距离有很多<strong>优点：</strong> <strong>马氏距离不受量纲的影响</strong>，两点之间的马氏距离与原始数据的测量单位无关；由标准化数据和中心化数据(即原始数据与均值之差）计算出的二点之间的马氏距离相同。<strong>马氏距离还可以排除变量之间的相关性的干扰</strong>。</p><h2 id="什么是马氏距离"><a href="#什么是马氏距离" class="headerlink" title="什么是马氏距离"></a>什么是马氏距离</h2><p>马氏距离(Mahalanobis Distance)是一种距离的度量，可以看作是欧氏距离的一种修正，修正了欧式距离中各个维度尺度不一致且相关的问题。</p><p>单个数据点的马氏距离</p><p><img src="https://pic4.zhimg.com/80/v2-d2987369d8167a362482d6cbecefb8bb_720w.jpg"></p><p>数据点x, y之间的马氏距离</p><p><img src="https://pic3.zhimg.com/80/v2-d54956df14c05568f8c0c0548ac16416_720w.jpg"></p><p><em>其中Σ是多维随机变量的协方差矩阵，μ为样本均值，如果协方差矩阵是单位向量，也就是各维度独立同分布，马氏距离就变成了欧氏距离。</em></p><h2 id="马氏距离实际意义"><a href="#马氏距离实际意义" class="headerlink" title="马氏距离实际意义"></a>马氏距离实际意义</h2><p>那么马氏距离就能能干什么？它比欧氏距离好在哪里？举几个栗子</p><p><strong>欧式距离近就一定相似？</strong></p><p>先举个比较常用的例子，身高和体重，这两个变量拥有不同的单位标准，也就是有不同的scale。比如身高用毫米计算，而体重用千克计算，显然差10mm的身高与差10kg的体重是完全不同的。但在普通的欧氏距离中，这将会算作相同的差距。</p><p><strong>归一化后欧氏距离近就一定相似？</strong></p><p>当然我们可以先做归一化来消除这种维度间scale不同的问题，但是样本分布也会影响分类</p><p>举个一维的栗子，现在有两个类别，统一单位，第一个类别均值为0，方差为0.1，第二个类别均值为5，方差为5。那么一个值为2的点属于第一类的概率大还是第二类的概率大？距离上说应该是第一类，但是直觉上显然是第二类，因为第一类不太可能到达2这个位置。</p><p>所以，在一个方差较小的维度下很小的差别就有可能成为离群点。就像下图一样，A与B相对于原点的距离是相同的。但是由于样本总体沿着横轴分布，所以B点更有可能是这个样本中的点，而A则更有可能是离群点。</p><p><img src="https://pic4.zhimg.com/80/v2-6f5d1b59fd1687cfeecd0c6991c6db77_720w.jpg"></p><p><strong>算上维度的方差就够了？</strong></p><p>还有一个问题——如果维度间不独立同分布，样本点一定与欧氏距离近的样本点同类的概率更大吗？</p><p><img src="https://pic3.zhimg.com/80/v2-3cee35b79d272dda86e2604c160934ee_720w.jpg"></p><p>可以看到样本基本服从f(x) = x的线性分布，A与B相对于原点的距离依旧相等，显然A更像是一个离群点</p><p>即使数据已经经过了标准化，也不会改变AB与原点间距离大小的相互关系。所以要本质上解决这个问题，就要针对<a href="https://link.zhihu.com/?target=https://www.ph0en1x.space/2018/03/06/PCA/">主成分分析</a>中的<code>主成分</code>来进行标准化。</p><h2 id="马氏距离的几何意义"><a href="#马氏距离的几何意义" class="headerlink" title="马氏距离的几何意义"></a>马氏距离的几何意义</h2><p>上面搞懂了，马氏距离就好理解了，<u>只需要将变量<code>按照主成分进行旋转</code>，让维度间相互<strong>独立</strong>，然后进行<code>标准化</code></u>，让维度<strong>同分布</strong>就可以了。</p><p>由主成分分析可知，由于主成分就是特征向量方向，每个方向的方差就是对应的特征值，所以只需要按照特征向量的方向旋转，然后缩放特征值倍就可以了，可以得到以下的结果：</p><p><img src="https://pic3.zhimg.com/80/v2-068306ff7e62b7af24b126eafe0b8bc6_720w.jpg"></p><p>离群点就被成功分离，这时候的欧式距离就是马氏距离。</p><h2 id="马氏距离的推导"><a href="#马氏距离的推导" class="headerlink" title="马氏距离的推导"></a>马氏距离的推导</h2><p>首先要对数据点进行<em>旋转</em>，旋转至主成分，维度间线性无关，假设新的坐标为</p><p><img src="https://pic2.zhimg.com/80/v2-e924839926a256cb277a8cfc850d5a89_720w.jpg"></p><p>又变换后<em>维度间线性无关且每个维度自己的方差为特征值</em>，所以满足：</p><p><img src="https://pic1.zhimg.com/80/v2-24ace781a1f0b2cc64ea359b1bb78d74_720w.jpg"></p><p>马氏距离是旋转变换缩放之后的欧式距离，所以马氏距离的计算公式为：</p><p><img src="https://pic3.zhimg.com/80/v2-4435a733478fafe47ee0198e315e67f6_720w.jpg"></p><p>这就是之前提到的马氏距离的公式</p><h2 id="马氏距离的问题"><a href="#马氏距离的问题" class="headerlink" title="马氏距离的问题"></a>马氏距离的问题</h2><ul><li>协方差矩阵必须满秩</li></ul><p>里面有求逆矩阵的过程，不满秩不行，要求数据要有原维度个特征值，如果没有可以考虑先进行PCA，这种情况下PCA不会损失信息</p><ul><li>不能处理非线性流形(manifold)上的问题</li></ul><p>只对线性空间有效，如果要处理流形，只能在局部定义，可以用来建立KNN图</p><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/46626607">https://zhuanlan.zhihu.com/p/46626607</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>概率论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马氏距离</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eckark_young定理</title>
    <link href="/2021/08/09/math/Eckark-young/"/>
    <url>/2021/08/09/math/Eckark-young/</url>
    
    <content type="html"><![CDATA[<p>最佳低秩逼近和奇异值的关系(<em>Eckart</em>-<em>Young定理</em>)</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>Suppose a matrix $A\in \mathbb{R}^{m\times n}$has an SVD-decomposition$A=U\Sigma V^T$. Let $k &lt; r= \mathsf{rank}(A)$and truncated matrix<br>$$<br>A_k = \sum_{i=1}^k \sigma_i \mathbf u_i \mathbf v_i^T,<br>$$<br>then, for any matrix B of rank k , the minimal error is achieved with $A_k$:</p>$$\min_{\mathsf{rank}(B)=k}||A-B||_2 = || A - A_k||_2 = \sigma_{k+1}.$$<p>The same holds for Frobenius norm as well</p>$$\min_{\mathsf{rank}(B)=k}||A-B||_F = || A - A_k||_F = \sqrt{\sigma_{k+1}^2 + \cdots + \sigma_p^2}.$$<h3 id="证明-2-norm-case"><a href="#证明-2-norm-case" class="headerlink" title="证明 (2-norm case)"></a>证明 (2-norm case)</h3><p>Since $U^\ A_k V = \mathrm{diag}(\sigma_1,\ldots, \sigma_k,0,\ldots,0)$ it means that $A_k$ is rank K. Moreover, $U^T (A-A_k) V =  \mathrm{diag}(0,\ldots, 0,\sigma_{k+1},\ldots, \sigma_p)$with the largest singular value is $\sigma_{k+1}$ and thus $||A-A_k||_2 = \sigma_{k+1}$.</p><h3 id="证明-Frobenius-norm-case"><a href="#证明-Frobenius-norm-case" class="headerlink" title="证明 (Frobenius norm case)"></a>证明 (Frobenius norm case)</h3><blockquote><p>Lemma: If $A,B \in \mathbb{R}^{m\times n}$ , with B having rank K , then $\sigma_{k+i}(A) \le \sigma_i(A-B) \text{ for all }; i.$</p></blockquote><p>To prove the lemma, first consider the case i=1, we have proved that $\sigma_{k+1}(A) \le \sigma_1(A-B) = ||A-B||_2$in the 2-norm case. Then we do the general case:</p>$$\begin{aligned} \sigma_i(A-B) = &amp; \sigma_i(A-B) + \sigma_1(B-B_k)\qquad\text{since } B=B_k\\ =&amp; \sigma_1(A-B - (A-B)_{i-1}) + \sigma_1(B-B_k)\qquad\\ \ge &amp; \sigma_1(A-B - (A-B)_{i-1}+B-B_k)   \\ =&amp; \sigma_1(A  - (A-B)_{i-1} -B_k)\\ \ge &amp; \sigma_1(A - A_{k+i-1})\\ =&amp; \sigma_{k+i}(A)   \end{aligned} $$<blockquote><p><a href="https://zhuanlan.zhihu.com/p/361938622">https://zhuanlan.zhihu.com/p/361938622</a></p><p><a href="https://zhuanlan.zhihu.com/p/75283604">https://zhuanlan.zhihu.com/p/75283604</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低秩逼近的思考</title>
    <link href="/2021/08/06/math/low-rank-app/"/>
    <url>/2021/08/06/math/low-rank-app/</url>
    
    <content type="html"><![CDATA[<blockquote><p>阅读文章<strong>Semi-orthogonal Embedding for Effificient Unsupervised Anomaly Segmentation</strong>时出现一个概念–<strong>Low-rank approximation</strong> ，就此进行相关讨论。</p></blockquote><h3 id="低秩（Low-Rank）"><a href="#低秩（Low-Rank）" class="headerlink" title="低秩（Low-Rank）"></a>低秩（Low-Rank）</h3><p>如果X是一个m行n列的数值矩阵，rank(X)是X的秩，假如rank (X)远小于m和n，则我们称X是低秩矩阵。低秩矩阵每行或每列都可以用其他的行或列线性表出，可见它包含大量的冗余信息。利用这种冗余信息，可以对缺失数据进行恢复，也可以对数据进行特征提取。</p><p>图像处理中，<em>rank可以理解为图像所包含的信息的丰富程度</em>，在显示生活中，一张图片中大部分成分是相似的。比如给一张大草原的图片</p><p><img src="https://pic1.zhimg.com/50/ce29981e00f4d519ff547e986bf8a5d6_720w.jpg?source=1940ef5c"></p><p>草原是由很多草组成的，而草是相似的，所以如果全是草，那么这张图所包含的信息量是很少的的，因为可以理解为草是草的复制品。而上图的蒙古包，人，马之类的则可以理解为图片所包含的信息，实际上，相对于只有草的草原图片和有草和蒙古包的草原图片，后者的秩是较高的。也就是说，图片中比较突兀的成分，比如蒙古包，比如人像照片中的红眼亮点，会增加图像矩阵的秩。而现实生活中一张不错的图片的秩其实是比较低的，如果图像的秩比较高，往往是因为图像中的噪声比较严重。比如拍照的时候ISO感光度设置过高造成噪点太过泛滥之类的。所以，<em>图像处理的低秩性其实可以拿来去除照片中的噪点</em>。</p><h3 id="低秩和稀疏"><a href="#低秩和稀疏" class="headerlink" title="低秩和稀疏"></a>低秩和稀疏</h3><p>我们认为图像有一些公共的模式，所有图像都由这些基本的模式组成。例如，如果图像是一个叉，可以看成是一个正斜线和反斜线的叠加。<strong>只要我们找到了所有的基底（称作字典</strong>，就是上面说的正斜线和反斜线之类的东西）<strong>，就能通过基底的线性组合表示出所有的图像。</strong>这就好像学画画，先学会基本的画正方体、球体、圆柱体等等，就可以组合出各种各样的复杂形状。</p><p><strong>在很多情形下，基底的数量是很少的</strong>，比如一张照片拍的是一面砖墙，那么它显然具有周期重复的特点，换句话说低秩。即使整个图不低秩，往往也能找出一些相似的块，这些块是低秩的。再退一步，就算这也做不到，往往也可以把已有的数据看成一组低维的结果加上噪声，也即原来的数据<strong>可以被低秩矩阵很好的逼近</strong>。<strong>稀疏性</strong>的意思是（以稀疏表示为例），任给一个图像，<strong>字典可能是过完备的</strong>，从而用字典里的基向量表出这幅图有很多种不同的方案。我们希望<strong>选取使用基底数量最少的那种方案</strong>，</p><p>应用：</p><p><em><strong>1）矩阵填充(Matrix Completion)</strong></em></p><p><em><strong>2）鲁棒PCA</strong></em></p><p><em><strong>3）背景建模</strong></em></p><p><em><strong>4）变换不变低秩纹理（TILT）</strong></em></p><blockquote><p>在论文 <strong>Semi-orthogonal Embedding for Effificient Unsupervised Anomaly Segmentation</strong>中有一段可以参考。</p></blockquote><p><strong>Low-rank approximation of precision matrix</strong></p><p>The feature data <strong>X</strong> is subject to low-rank approximation due to the narrower target domain for anomaly-free images than the ImageNet dataset’s. The multi-scale features from different layers may also contribute to it due to the inter-dependency among the features from the layers. Inspired by the truncated SVD of a precision matrix, a low-rank embedding of input features with <strong>W</strong> <em>∈</em> $R^{F<em>k}$,where <em>F &gt; k</em>, is considered as follows:<br>$$<br>d^2_{i,j} = X^TW(W^TC_{i,j}W)^{−1}W^TX<br>$$<br>where the below Theorem 1 shows the optimal <strong>W</strong></em> is the eigenvectors related to the <em>k</em>-smallest eigenvalues of $C_{i,j}$ . Notice that 1) the computational complexity of the equation is cubically reduced to <em>O</em>($HWk^3$) set aside the cost of SVD, although which is the concern, 2) PCA embedding would fail to minimize approximation error since it uses the <em>k</em>-largest eigenvectors [14], and 3) near-zero eigenvalues may induce substantial anomaly scores.</p><p>选取协方差矩阵的k个最小的特征值对应的特征向量，进行低秩逼近</p><blockquote><p>参考</p><p> <a href="https://www.zhihu.com/question/28630628">https://www.zhihu.com/question/28630628</a></p><p><a href="https://blog.csdn.net/zouxy09/article/details/24972869">https://blog.csdn.net/zouxy09/article/details/24972869</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>线性代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子模块为空的解决方案</title>
    <link href="/2021/08/06/git_config/git-submodule/"/>
    <url>/2021/08/06/git_config/git-submodule/</url>
    
    <content type="html"><![CDATA[<blockquote><p>针对子模块文件夹为空的情况，采取下列解决方案。</p><p>当一个 git 项目包含子模块（submodule) 时，直接克隆下来的子模块目录里面是空的。</p></blockquote><p><strong>有两种方法解决</strong>：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>如果项目已经克隆到了本地，执行下面的步骤：</p><ol><li><p>初始化本地子模块配置文件</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git submodule <span class="hljs-keyword">init</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>更新项目，抓取子模块内容。</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git submodule update</span><br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>另外一种更简单的方法，就是在执行 <code>git clone</code> 时加上 <code>--recursive</code> 参数。它会自动初始化并更新每一个子模块。例如：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone --recursive https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/example/</span>example.git<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中公式显示</title>
    <link href="/2021/08/05/hexo_config/hexo-math-config/"/>
    <url>/2021/08/05/hexo_config/hexo-math-config/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公式的显示问题。Hexo中Mathjax是用于显示公式的插件，但是多行显示会出现问题，有时还会出现乱码的情况。</p></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在根目录下的config_fluid.yml​文件中打开math的相关配置。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br><span class="hljs-comment"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># Options: mathjax | katex</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><ul><li>由于hexo解码时关注，%% 等连续字符，会将这部分代码解读为其他带有特殊含义的内容</li><li>如果公式中恰巧出现了此类字符，会报出上述错误</li></ul><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><ul><li>由于hexo在公式中的<code>\\</code>错会成了转义符，也就是说他只看见了一个反斜杠，不会执行换行命令，导致公式堆成一行</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="临时方案"><a href="#临时方案" class="headerlink" title="临时方案"></a>临时方案</h4><h5 id="针对问题1"><a href="#针对问题1" class="headerlink" title="针对问题1"></a>针对问题1</h5><ul><li>可以在连续的 <code>{</code> <code>}</code> <code>%</code>中间插入空格，分开就没事了</li></ul><h5 id="针对问题2"><a href="#针对问题2" class="headerlink" title="针对问题2"></a>针对问题2</h5><ul><li>可以将<code>\\</code>换成<code>\\\\</code>，可以实现公式的多行正确显示</li></ul><h4 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h4><ul><li><p>在官方文档中提到了可以为hexo提供标记，阻止其按照自己的规则解释我们的字符串，显示其原本的含义</p></li><li><p>标记为</p><figure class="highlight django"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">{% <span class="hljs-name">raw</span> %}</span><span class="xml"></span><br><span class="xml">$$</span><br><span class="xml">...</span><br><span class="xml">$$</span><br><span class="xml"></span><span class="hljs-template-tag">{% <span class="hljs-name">endraw</span> %}</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="多行显示和对齐"><a href="#多行显示和对齐" class="headerlink" title="多行显示和对齐"></a>多行显示和对齐</h3><ul><li><p>默认是显示为一行要实现公式多行和对齐可以使用{aligned}模式，使用”&amp;”来标记对齐位置。”\\“表示换行</p>  <figure class="highlight taggerscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">$$<br><span class="hljs-symbol">\b</span>egin{aligned}<br><span class="hljs-symbol">\b</span>oldsymbol{x}^{<span class="hljs-symbol">\m</span>athrm{T}}C<span class="hljs-symbol">\b</span>oldsymbol{x}&amp;=<span class="hljs-symbol">\b</span>oldsymbol{x}^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft[<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\r</span>ight]<span class="hljs-symbol">\b</span>oldsymbol{x} <br><span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft[<span class="hljs-symbol">\b</span>oldsymbol{x}^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight] <span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft[<span class="hljs-symbol">\l</span>eft(<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\l</span>eft(<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight)<span class="hljs-symbol">\r</span>ight] <br><span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft(<span class="hljs-symbol">\l</span>eft<span class="hljs-symbol">\V</span>ert <span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight<span class="hljs-symbol">\V</span>ert ^{2}<span class="hljs-symbol">\r</span>ight) <br><span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\s</span>igma_{X}^{2}<br><span class="hljs-symbol">\e</span>nd{aligned}<br>$$<br></code></pre></td></tr></tbody></table></figure></li><li><p>显示为</p></li></ul>$$\begin{aligned}\boldsymbol{x}^{\mathrm{T}}C\boldsymbol{x}&amp;=\boldsymbol{x}^{\mathrm{T}}\mathrm{E}\left[\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\right]\boldsymbol{x} \\&amp;=\mathrm{E}\left[\boldsymbol{x}^{\mathrm{T}}\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right] \\&amp;=\mathrm{E}\left[\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)^{\mathrm{T}}\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)\right] \\&amp;=\mathrm{E}\left(\left\Vert \left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right\Vert ^{2}\right) \\&amp;=\sigma_{X}^{2}\end{aligned}$$]]></content>
    
    
    <categories>
      
      <category>配置</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>直观理解协方差矩阵</title>
    <link href="/2021/08/05/math/covariance-matrix/"/>
    <url>/2021/08/05/math/covariance-matrix/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文出自 <a href="https://zhuanlan.zhihu.com/p/349802953">https://zhuanlan.zhihu.com/p/349802953</a></p></blockquote><h2 id="1-概率论中的定义"><a href="#1-概率论中的定义" class="headerlink" title="1 概率论中的定义"></a>1 概率论中的定义</h2><h3 id="随机变量："><a href="#随机变量：" class="headerlink" title="随机变量："></a>随机变量：</h3><p>随机变量(Random Variable) X 是一个映射，把随机试验的结果与实数建立起了一一对应的关系。而期望与方差是随机变量的两个重要的数字特征。</p><h3 id="数学期望："><a href="#数学期望：" class="headerlink" title="数学期望："></a>数学期望：</h3><p>在概率论和统计学中，数学期望(mean)(或均值，亦简称期望(Expectation, or expected value))是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。 期望值是该变量输出值的平均数。期望值并不一定包含于变量的输出值集合里。</p><p>大数定律规定，随着重复次数接近无穷大，数值的算术平均值几乎肯定地收敛于期望值。</p><h3 id="方差："><a href="#方差：" class="headerlink" title="方差："></a>方差：</h3><p>方差(Variance)是在概率论和统计方差衡量随机变量或一组数据时离散程度的度量。概率论中方差用来度量随机变量和其数学期望(即均值)之间的偏离程度。统计中的方差(样本方差)是每个样本值与全体样本值的平均数之差的平方值的平均数。</p><p>设$X$为随机变量， 如果$\mathrm{E}[X]$，则随机变量$X$的方差为：<br>$$<br>\mu=\mathrm{E}[X]<br>$$</p><p>方差也记为 $\sigma_{X}^{2}$。</p><p>样本方差计算公式：</p><p>$$<br>S^{2}=\Sigma\left(X-\overline{X}\right)^{2}/\left(n-1\right)<br>$$</p><p>其中，$S^{2}$为样本方差，$X$ 为变量，$\overline{X}$为样本均值，$n$ 为样本例数。如果要了解为什么要除以$n-1$，请看<a href="https://link.zhihu.com/?target=https://www.visiondummy.com/2014/03/divide-variance-n-1/">这篇文章</a>。</p><h3 id="标准差："><a href="#标准差：" class="headerlink" title="标准差："></a>标准差：</h3><p>标准差(Standard Deviation)是离均差平方的算术平均数(即：方差)的算术平方根，用$\sigma$表示。标准差也被称为标准偏差，或者实验标准差，在概率统计中最常使用作为统计分布程度上的测量依据。 见下图：</p><p><img src="https://pic1.zhimg.com/80/v2-37e04458baf17d09c914981b5dbae140_720w.jpg"></p><p>标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的两组数据，标准差未必相同。</p><h3 id="协方差："><a href="#协方差：" class="headerlink" title="协方差："></a>协方差：</h3><p><strong>协方差(Covariance)在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</strong></p><p>期望值分别为$ E[X]$与$[Y]$的两个实随机变量$X$与$Y$之间的协方差 $\mathrm{Cov}(X,Y)$ 定义为：</p>$$\begin{aligned}\mathrm{Cov}(X,Y)&amp;=\mathrm{E}\left[\left(X\mathrm{E}\left[X\right]\right)\left(Y-\mathrm{E}\left[Y\right]\right)\right]  \\&amp;=\mathrm{E}\left[XY\right]-2\mathrm{E}\left[Y\right]\mathrm{E}\left[X\right]+\mathrm{E}\left[X\right]\mathrm{E}\left[Y\right]\\&amp;=\mathrm{E}\left[XY\right]-\mathrm{E}\left[X\right]\mathrm{E}\left[Y\right] \\&amp;=\mathrm{E}\left[XY\right]-\mathrm{E}\left[X\right]\mathrm{E}\left[Y\right]\end{aligned}$$<p>协方差表示的是两个变量总体误差的期望。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。</p><p>如果$X$与$Y$是统计独立的，那么二者之间的协方差就是0，因为两个独立的随机变量满足$\mathrm{E}[XY]=\mathrm{E}[X]\mathrm{E}[Y]$。但是，反过来并不成立。即如果$X$与$Y$的协方差为0，二者并不一定是统计独立的。</p><p><strong>协方差为0的两个随机变量称为是不相关的。</strong></p><h3 id="协方差矩阵："><a href="#协方差矩阵：" class="headerlink" title="协方差矩阵："></a>协方差矩阵：</h3><p>在统计学与概率论中，协方差矩阵(Covariance matrix)的每个元素是各个向量元素之间的协方差，是从标量随机变量到高维度随机向量的自然推广。</p><p>设$X=\left(X_{1},X_{2},\ldots,X_{n}\right)^{\mathrm{T}}$为$n$ 维随机变量，称矩阵</p>$$C=\left(\begin{array}{cccc} c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n}\\ c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn} \end{array}\right)$$<p>为 n 维随机变量x的协方差矩阵，也记为 $D\left(X\right)$ ，其中<br>$$<br>c_{ij}=\mathrm{Cov}(X_{i},X_{j}),\quad i,j=1,2,\ldots,n<br>$$<br>为X的分量$X_{i}$和$X_{j}$的协方差。<em>并且对角线上的元素为各个随机变量的方差：</em></p><p>$$<br>c_{ii}=\mathrm{Cov}(X_{i},X_{i}),\quad i=1,2,\ldots,n<br>$$</p><p>协方差矩阵是对称半正定矩阵。协方差矩阵的对称性，可从定义得知。对于半正定特性，证明如下：</p><p>现给定任意一个非零向量$\boldsymbol{x}$，则</p>$$\begin{aligned}\boldsymbol{x}^{\mathrm{T}}C\boldsymbol{x}&amp;=\boldsymbol{x}^{\mathrm{T}}\mathrm{E}\left[\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\right]\boldsymbol{x} \\&amp;=\mathrm{E}\left[\boldsymbol{x}^{\mathrm{T}}\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right] \\&amp;=\mathrm{E}\left[\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)^{\mathrm{T}}\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)\right] \\&amp;=\mathrm{E}\left(\left\Vert \left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right\Vert ^{2}\right) \\&amp;=\sigma_{X}^{2}\end{aligned}$$<p>其中，<br>$$<br>\sigma_{X}=\left(X-\mu \right)^{\mathrm{T}}\boldsymbol{x}<br>$$<br>由于 $\sigma_{X}^{2}\geq0$，因此$\boldsymbol{x}^{\mathrm{T}}C\boldsymbol{x}\geq0$，因此协方差矩阵$C$ 是半正定矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>概率论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
