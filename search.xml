<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客中的emoji</title>
      <link href="/2021/08/24/hexo_config/hexo-emoji/"/>
      <url>/2021/08/24/hexo_config/hexo-emoji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在博客中使用emoji，可可爱爱小表情😍</p></blockquote><blockquote><p>相关配置参见这个博客哟 <a href="https://www.zywvvd.com/2021/08/23/hexo/19%20hexo-emoji/hexo-emoji/">Hexo -19- 添加emoji表情</a><br>可以在这两个网站看看有哪些小表情<br><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a><br><a href="https://www.zywvvd.com/2021/08/13/git/git-emoji/git-emoji/">https://www.zywvvd.com/2021/08/13/git/git-emoji/git-emoji/</a></p></blockquote><h2 id="安装渲染器">安装渲染器</h2><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">npm un hexo-renderer-marked <span class="hljs-comment">--save</span><br>npm i hexo-renderer-markdown-<span class="hljs-keyword">it</span> <span class="hljs-comment">--save</span><br></code></pre></td></tr></tbody></table></figure><h2 id="修改配置文件">修改配置文件</h2><p>在_config.yml文件尾部添加下段代码</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Markdown-it config</span><br><span class="hljs-comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">render:</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">quotes:</span> <span class="hljs-string">'“”‘’'</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span>  <span class="hljs-comment"># add emoji</span><br></code></pre></td></tr></tbody></table></figure><p>使用的时候就直接在md文件中用两个引号中间填写emoji的名称即可啦 :happy:</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emoji </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO学习</title>
      <link href="/2021/08/21/deep_learning/yolo/"/>
      <url>/2021/08/21/deep_learning/yolo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>YOLO系列是基于深度学习的回归方法。YOLO：you only look once的优点是实时快速目标检测。一直都很想把YOLO系统的学习一下。在此，记录下相关的知识和个人理解。做笔记也算是督促我好好的整理相关内容叭！ok开始！😉</p></blockquote><blockquote><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/136382095">https://zhuanlan.zhihu.com/p/136382095</a><br><a href="https://mp.weixin.qq.com/s/df1JaGtnoEY4FQford4UIw">https://mp.weixin.qq.com/s/df1JaGtnoEY4FQford4UIw</a></p></blockquote><h2 id="YOLO-和-Faster-R-CNN">YOLO 和 Faster R-CNN</h2><p>两个网络的差异有两个方面：</p><ol><li><p>Yolo没有显示求取region proposal的过程，虽然Faster R-CNN中的RPN于Fast R-CNN共享卷积层，但是在模型训练过程中，还是需要反复的训练RPN于Fast R-CNN，也就是说这种方式还是需要”look twice“ ：确定候选框和分类；而Yolo系列只需要”look once“</p><blockquote><p>关于Faster R-CNN的知识后续再填坑…</p></blockquote></li><li><p>Yolo将检测统一为一个回归问题。而R-CNN将检测结果分为两个部分进行求解：分类<code>物体的类别</code> ， 回归<code>物体的bounding  box</code></p></li></ol><h2 id="YOLOv1">YOLOv1</h2><p>**论文下载：**<a href="http://arxiv.org/abs/1506.02640">http://arxiv.org/abs/1506.02640</a></p><p>**代码下载：**<a href="https://github.com/pjreddie/darknet">https://github.com/pjreddie/darknet</a></p><p>核心思想：将整张图作为网络的输入（与Faster-RCNN类似），直接在输出层对BBox的位置和类别进行回归。</p><p>实现方法：</p><p><img src="https://picture.mulindya.com/yolov1-pic1.png" alt=""></p><ul><li><p>首先将一幅图像分成S*S个网格（grid cell）,如果某个物体的中心落在这个网格中，那么这个网格就负责预测这个物体。</p></li><li><p>每个网格需要预测B个边界框(BBox)的位置信息和对应的置信度（confidence）;一个BBox对应四个位置信息和一个confidence信息，confidence表示所预测的Box中含有objext的置信度和box的预测情况。</p><blockquote><p>也就是$conf = Pr(object)\times IOU^{truth}_{pred}$ 如果有object落在其中的grid cell里，那么第一项为1否则取0.</p></blockquote></li></ul><p>每个bounding box要预测(x, y, w, h)和confidence共5个值，每个网格还要预测一个类别信息，记为C类。则SxS个网格，每个网格要预测B个bounding box还要预测C个categories。判断这个落在此网格的物体是c个物体中的哪一个物体。输出就是S x S x (5*B+C)的一个tensor。（<strong>注意：class信息是针对每个网格的，confidence信息是针对每个bounding box的。</strong>）</p><p>举例说明: 在PASCAL VOC中，图像输入为448x448，取S=7，B=2，一共有20个类别(C=20)。则输出就是7x7x30的一个tensor。*其中30也就是2*5+20，整个网络结构如下图所示：</p><p><img src="https://picture.mulindya.com/yolov1-pic2.png" alt=""></p><p>在test的时候，每个网格预测的class信息与BBox得到的confidenci信息相乘，就可以得到每个BBox的class-specific confidence score：</p>$$Pr(Class_i \vert Object) \times Pr(Object) \times IOU^{truth}_{pred} = Pr(Class_i) \times IOU^{truth}_{pred}$$<p>得到每个box的class-specific confidence score之后，设置阈值，过滤掉得分低的boxes，对保留的boxes进行NMS处理，即可得到最终的检测结果。</p><blockquote><p>NMS：non-maximum suppression 非极大抑制，其操作即是从集合中找到得分score最高的候选框，与其他候选框计算IOU，删除重合率高的候选框，因为这些候选框和最高score的框“竞争”同一个物体，但是score又不够高，所以是应该被淘汰的。确定了这个最高score的BBOX之后就可以不考虑他了，再继续找寻最高score的候选框，把与他竞争的候选框给pass掉即可，以此类推。</p></blockquote><h4 id="流程">流程</h4><ol><li>输入一张图像将其分为7*7的网格</li><li>对于每一个网格,预测两个边框；（包括边框的置信度和其对应的类别概率）</li><li>根据预测的7*7*2的目标窗口，首先通过阈值去除可能性地的窗口，再采用NMS去除冗余的窗口。</li></ol><h3 id="损失函数">损失函数</h3><p>最重要的是设计损失函数，作者使用了sum-squared error loss（<a href="https://blog.csdn.net/shengyan5515/article/details/84036734%EF%BC%89">https://blog.csdn.net/shengyan5515/article/details/84036734）</a></p><blockquote><p>关于YOLO的损失函数，采用sum-squared error整合localization error（bboxes的坐标误差）和classification error，其中classification error包括两部分，一部分是没有包含object的box的confidence loss权值，另一部分则是有包含object的box的confidence loss权值</p></blockquote><p><img src="https://picture.mulindya.com/yolov1-pic3.png" alt=""></p><h4 id="问题：">问题：</h4><ul><li>8维的localization error(4*2),和20维的classification error同等重要是不合理的</li><li>如果一个网格中没有object(大部分),将这些网格的box对应confidence设置为0，是比较“暴力”的，会让loss特别大，网络不稳定并且不容易收敛。</li></ul><h4 id="解决方案：">解决方案：</h4><ul><li><p>对于坐标预测赋予更大的权重（重视框的位置）</p></li><li><p>对没有object的confidence loss，赋予小的权重(注意力转移到其他地方)</p></li><li><p>对存在object的box的confidence loss和类别的预测权重正常取1</p></li></ul><blockquote><p>为什么第二项出现了根号呢？</p><p>是因为我们的误差度量量反应出大box的小偏差要小于小box。为了逐步解决这个问题，我们预测了边界框的宽度和高度的平⽅根，而不是直接预测宽度和⾼度。因为根号之后曲线越大越平缓。这样对小的box的偏差相对更加敏感。</p></blockquote><p>观察损失函数可以看出：</p><ul><li><p>只有在网格中存在object的时候才会对classification error进行计算</p></li><li><p>只有当某个网格的box的和对于的ground truth box是负责回归的，才会对这个box 的位置xywh损失进行计算，确定对应ground truth box就需要将这个box与这个网格中的所有bbox计算IOU，最大的那个ground truth是由这个网络负责预测的。</p><p>激活函数使用的是leak relu，模型是使用预训练的Imagenet。</p></li></ul><h3 id="优点">优点</h3><ul><li><p>快速，pipline简单</p></li><li><p>背景误检率低</p></li><li><p>通用性强，对艺术品中的物体也可以检测，对非自然的图像物体的检测率比一般的DOM，R-CNN都要好很多</p></li></ul><h3 id="缺点">缺点</h3><ul><li>由于输出层是全连接层，因此在检测时，YOLO训练模型只能支持与训练图像分辨率相同的图像</li><li>每个格子可以预测B个Bbox，但是最终只能选择IOU最高的BBox作为物体检测结果，也就是说，一个各自只能最多预测出一个物体；当物体比较小或者分布密集的时候也只能检测出一个。</li><li>在loss的求解方程中，大目标和小目标的IOU误差在loss计算上是接近的（即使用了平方根缓解），因此对于小物体的检测准确性不高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer19</title>
      <link href="/2021/08/21/leetcode/leetcode-offer19/"/>
      <url>/2021/08/21/leetcode/leetcode-offer19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式匹配</p></blockquote><h2 id="题目">题目</h2><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.‘表示任意一个字符，而’</em>'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab<em>ac</em>a"匹配，但与"aa.a"和"ab*a"均不匹配。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">"aa"</span><br>p = <span class="hljs-string">"a"</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: "a" 无法匹配 "aa" 整个字符串。</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight smalltalk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入:<br>s = <span class="hljs-comment">"aa"</span><br>p = <span class="hljs-comment">"a*"</span><br>输出: <span class="hljs-keyword">true</span><br>解释:&nbsp;因为 <span class="hljs-string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="hljs-string">'a'</span>。因此，字符串 <span class="hljs-comment">"aa"</span> 可被视为 <span class="hljs-string">'a'</span> 重复了一次。<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-3：">示例 3：</h3><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">"ab"</span><br>p = <span class="hljs-string">".*"</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-4：">示例 4：</h3><figure class="highlight smalltalk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入:<br>s = <span class="hljs-comment">"aab"</span><br>p = <span class="hljs-comment">"c*a*b"</span><br>输出: <span class="hljs-keyword">true</span><br>解释:&nbsp;因为 <span class="hljs-string">'*'</span> 表示零个或多个，这里 <span class="hljs-string">'c'</span> 为 <span class="hljs-number">0</span> 个, <span class="hljs-string">'a'</span> 被重复一次。因此可以匹配字符串 <span class="hljs-comment">"aab"</span>。<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-5：">示例 5：</h3><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>s = <span class="hljs-string">"mississippi"</span><br>p = <span class="hljs-string">"mis*is*p*."</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>'*'</code>。</li></ul><h2 id="题解">题解</h2><p>动态规划的核心是建立状态转移方程。dp[i][j]表示前j个模式串匹配s的前i个字母的匹配情况。</p><p>那么就要分情况讨论了，一种是p[j]是<code>字母</code>，第二是<code> .</code> ,第三是 <code>*</code>.</p><ol><li><p><code>字母</code>:直接判断是否一致，如果$p[j]==s[i]$就可以转移 $dp[i][j] = dp[i-1][j-1]$</p></li><li><p><code> .</code> : 可以匹配任意字符直接转移$dp[i][j] = dp[i-1][j-1]$</p></li><li><p><code>*</code>：如果前一个字符$p[j-1]==s[i]$，那么这个<code>*</code>可以选择是匹配s的<strong>一个元素还是多个元素</strong></p><p>$dp[i][j] = dp[i][j-2] \quad or \quad dp[i-1][j]$</p></li></ol><p>如果元素不相等，就直接向前匹配（0次匹配）$dp[i][j-2]$</p><blockquote><p>$dp[i][j-2]$是匹配0个；$dp[i-1][j]$是匹配多个，忽略i元素继续向前查找；$dp[i-1][j-2]$是匹配1个是包含于多个$dp[i-1][j]$中</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isMatch</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        s = <span class="hljs-string">" "</span>+s<br>        p = <span class="hljs-string">" "</span>+p<br>        dp = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(p)):<br>                <span class="hljs-keyword">if</span>(p[j]!=<span class="hljs-string">'*'</span>):<br>                    <span class="hljs-keyword">if</span>((p[j]==<span class="hljs-string">'.'</span> <span class="hljs-keyword">and</span> s[i]!=<span class="hljs-string">" "</span>) <span class="hljs-keyword">or</span> p[j]==s[i]):<br>                        dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span>(p[j-<span class="hljs-number">1</span>]==s[i] <span class="hljs-keyword">or</span> (p[j-<span class="hljs-number">1</span>]==<span class="hljs-string">'.'</span> <span class="hljs-keyword">and</span> s[i]!=<span class="hljs-string">" "</span>)): dp[i][j] = dp[i][j-<span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> dp[i-<span class="hljs-number">1</span>][j] <br>                    <span class="hljs-comment">#dp[i][j] = dp[i][j-2] or dp[i-1][j] #直接0次或者多次</span><br>                    <span class="hljs-keyword">else</span>:dp[i][j] = dp[i][j-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>][<span class="hljs-built_in">len</span>(p)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer18 删除链表的节点</title>
      <link href="/2021/08/21/leetcode/leetcode-offer18/"/>
      <url>/2021/08/21/leetcode/leetcode-offer18/</url>
      
        <content type="html"><![CDATA[<blockquote><p>删除链表的节点</p></blockquote><h2 id="题目">题目</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<br>注意：此题对比原题有改动</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: head = [4,5,1,9], val = 5</span><br><span class="hljs-section">输出: [4,1,9]</span><br><span class="hljs-section">解释: 给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: head = [4,5,1,9], val = 1</span><br><span class="hljs-section">输出: [4,5,9]</span><br><span class="hljs-section">解释: 给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</li></ul><h2 id="题解">题解</h2><p>常规操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteNode</span>(<span class="hljs-params">self, head: ListNode, val: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span><br>        p = head<br>        <span class="hljs-keyword">if</span>(head.val==val):<span class="hljs-keyword">return</span> p.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span>(p.<span class="hljs-built_in">next</span>):<br>            <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">next</span>.val == val):<br>                p.<span class="hljs-built_in">next</span> = p.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">return</span> head<br>            p = p.<span class="hljs-built_in">next</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer24 反转链表</title>
      <link href="/2021/08/21/leetcode/leetcode-offer24/"/>
      <url>/2021/08/21/leetcode/leetcode-offer24/</url>
      
        <content type="html"><![CDATA[<blockquote><p>反转链表</p></blockquote><h2 id="题目">题目</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 节点个数 &lt;= 5000</li></ul><h2 id="题解">题解</h2><p>比较常规，遍历链表把元素移动到头节点。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(head):<span class="hljs-keyword">return</span> head<br>        p = head.<span class="hljs-built_in">next</span><br>        head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span>(p):<br>            t = p.<span class="hljs-built_in">next</span><br>            p.<span class="hljs-built_in">next</span> = head<br>            head = p<br>            p = t<br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer16  数值的整数次方</title>
      <link href="/2021/08/21/leetcode/leetcode-offer16/"/>
      <url>/2021/08/21/leetcode/leetcode-offer16/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数值的整数次方</p></blockquote><h2 id="题目">题目</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.00000</span>, n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1024.00000</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：x = <span class="hljs-number">2.10000</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">9.26100</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>-100.0 &lt; x &lt; 100.0</li><li>$-2^{31}$ &lt;= n &lt;= $2^{31}-1$</li><li>$-10^4$ &lt;= $x^n$ &lt;= $10^4$</li></ul><h2 id="题解">题解</h2><p>一种方法是将x乘以n次，但是这种时间复杂度是O(n)。判题时时间超出限制。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>):<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        result=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>):<br>            n = -n<br>            x = <span class="hljs-number">1</span>/x<br>        <span class="hljs-keyword">while</span>(n):<br>            result *= x<br>            n -=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></tbody></table></figure><p>实际上可以利用x *= x 和对n右移操作可以得到$x,x<sup>2,x</sup>4,x<sup>8,x</sup>{16}…$，而$x<sup>{11}$可以二进制指数表示为$x</sup>{1011}$也就是$x \times x^2 \times x^8$。这样原本需要循环11次就只需要循环4次</p><p>根据提示条件，循环最多不会超过32次。就很棒！</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>):<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        result=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>):<br>            n = -n<br>            x = <span class="hljs-number">1</span>/x<br>        <span class="hljs-keyword">while</span>(n): <span class="hljs-comment">#时间复杂度大大降低 不超过32次 O(logn)</span><br>            <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>):result *= x <span class="hljs-comment">#看最后一位是否为1</span><br>            x *= x<br>            n = n&gt;&gt;<span class="hljs-number">1</span> <span class="hljs-comment">#n右移 1011-》101</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 快速幂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer17 打印从1到最大的n位数</title>
      <link href="/2021/08/20/leetcode/leetcode-offer17/"/>
      <url>/2021/08/20/leetcode/leetcode-offer17/</url>
      
        <content type="html"><![CDATA[<blockquote><p>打印从1到最大的n位数</p></blockquote><h2 id="题目">题目</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: n = <span class="hljs-number">1</span><br>输出: [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>用返回一个整数列表来代替打印</li><li>n 为正整数</li></ul><h2 id="题解">题解</h2><p>借用python的类型转换的包容性，直接可以返回列表</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printNumbers</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,n))] <span class="hljs-comment">#或者10**n</span><br></code></pre></td></tr></tbody></table></figure><p>实际上，考点是大数越界情况下的打印。<br>解决思路，用字符串的全排列来解决数字的越界情况。基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当 n = 2时（数字范围 1 - 99 ），固定十位为 0- 9 ，按顺序依次开启递归，固定个位 0 - 9 ，终止递归并添加数字字符串。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printNumbers</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; [<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">x</span>):</span><br>            <span class="hljs-keyword">if</span> x == n:<br>                s = <span class="hljs-string">''</span>.join(num[self.start:])<br>                <span class="hljs-keyword">if</span> s != <span class="hljs-string">'0'</span>: res.append(<span class="hljs-built_in">int</span>(s))<br>                <span class="hljs-keyword">if</span> n - self.start == self.nine: self.start -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">9</span>: self.nine += <span class="hljs-number">1</span><br>                num[x] = <span class="hljs-built_in">str</span>(i)<br>                dfs(x + <span class="hljs-number">1</span>)<br>            self.nine -= <span class="hljs-number">1</span><br>        <br>        num, res = [<span class="hljs-string">'0'</span>] * n, []<br>        self.nine = <span class="hljs-number">0</span><br>        self.start = n - <span class="hljs-number">1</span><br>        dfs(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></tbody></table></figure><ul><li>字符串左边界定义： 声明变量 start 规定字符串的左边界，以保证添加的数字字符串 num[start:] 中无高位多余的 0 。例如当 n = 2 时, 1 - 9时 start = 1， 10 - 99 时 start = 0。</li><li>左边界 start 变化规律： 观察可知，当输出数字的所有位都是 9 时，则下个数字需要向更高位进 11 ，此时左边界 start 需要减11 （即高位多余的 0 减少一个）。例如当 n = 3（数字范围 1 - 999 ）时，左边界 start 需要减 1 的情况有： “009” 进位至 “010” ， “099” 进位至 “100” 。设数字各位中 9 的数量为 nine ，所有位都为 9 的判断条件可用以下公式表示：n - start = nine统计 nine 的方法： 固定第 x 位时，当 i = 9则执行 nine = nine + 1 ，并在回溯前恢复 nine = nine - 1</li></ul>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 大数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 大数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拉普拉斯算子</title>
      <link href="/2021/08/20/img_process/laplace/"/>
      <url>/2021/08/20/img_process/laplace/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​图像锐化处理的作用是使灰度反差增强，从而使模糊图像变得更加清晰。图像模糊的实质就是图像受到平均运算或积分运算，因此可以对图像进行逆运算，如微分运算能够突出图像细节，使图像变得更为清晰。<br>​积分运算的模板可以平滑图像，反过来对应微分运算的模板卷积可以锐化图像。锐化模板系数的取值再中心为正数而周围为负数。或者中心为负数周围为正数。而拉普拉斯算子就是一种常用的线性锐化滤波的方法。</p></blockquote><h2 id="拉普拉斯的背景">拉普拉斯的背景</h2><p>在图像中的边缘区域，像素值会发生“跳跃”，对这些像素求导，在其一阶导数在边缘位置为极值（Sobel算子）：</p><p><img src="https://picture.mulindya.com/laplace-pic1.png" alt="img"></p><p>如果对像素值求二阶导数，会发现边缘处的导数值为0；<strong>但是并不是说二阶导数为0就意味着是边缘</strong>。</p><p><img src="https://picture.mulindya.com/laplace-pic2.png" alt=""></p><h2 id="计算方法">计算方法</h2><h3 id="像素二阶导数">像素二阶导数</h3><p>二阶导数的计算方法：<br>$$<br>\nabla^2f = \frac{\partial^2 f}{\partial x<sup>2}+\frac{\partial</sup>2 f}{\partial y^2}<br>$$<br>分别沿着X和Y方向有二阶偏导数均可借用差分计算：<br>$$<br>\frac{\partial^2 f}{\partial x^2} = f(x+1,y)+f(x-1,y)-2f(x,y)<br>$$</p><p>$$<br>\frac{\partial^2 f}{\partial y^2} = f(x,y+1)+f(x,y-1)-2f(x,y)<br>$$</p><p>那么可以得到<br>$$<br>\nabla^2f = f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)<br>$$</p><h3 id="模板卷积">模板卷积</h3><p>对应的模板卷积即为</p>$$\begin{bmatrix} 0 &amp; 1 &amp; 0\\ 1 &amp; -4 &amp; 1 \\ 0 &amp; 1 &amp; 0 \end{bmatrix} 或者\begin{bmatrix} 0 &amp; -1 &amp; 0 \\ -1 &amp; 4 &amp; -1 \\ 0 &amp; -1 &amp; 0 \end{bmatrix}$$<p>前者是mask中心为负数，后者是mask中心为正数；他们的目的和效果是一致的，只是表现形式稍有不同，前者在卷积后，在边缘的亮处为负数，在边缘暗处为正数。后者相反。</p><p>mask为负数时，在边缘的亮处为负数，在边缘暗处为正数。可以参见下图：</p><p><img src="https://picture.mulindya.com/laplace-pic3.png" alt=""></p><p>上述是考虑中心像素4邻域，类似还有考虑8邻域，此时中心点区8或-8，周围为-1或1。</p>$$\begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; -8 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix} 或者\begin{bmatrix} -1 &amp; -1 &amp; -1 \\ -1 &amp; 8 &amp; -1 \\ -1 &amp; -1 &amp; -1 \end{bmatrix}$$<h2 id="图像锐化">图像锐化</h2><p>锐化处理可选择拉普拉斯算子对原图像进行处理，产生描述灰度突变的图像，再将拉普拉斯图像与原始图像叠加而产生锐化图像。拉普拉斯锐化的基本方法可以由下式表示：<br>$$<br>g(x,y) = \begin{cases} f(x,y) - \nabla^2f(x,y) &amp; \text{mask中心为负数}\f(x,y) + \nabla^2f(x,y) &amp; \text{mask中心为正数} \end{cases}<br>$$</p><p>这种简单的锐化方法既可以产生拉普拉斯锐化处理的效果，同时又能保留背景信息，将原始图像叠加到拉普拉斯变换的处理结果中去，可以使图像中的各灰度值得到保留，使灰度突变处的对比度得到增强，<strong>最终结果是在保留图像背景的前提下，突现出图像中小的细节信息</strong>。</p><p>缺点是没有了边缘的方向信息；双倍加强了噪声的影响。</p><blockquote><p>锐化处理的公式从模板形式容易看出，如果在图像中一个较暗的区域中出现了一个亮点，那么用拉普拉斯运算就会使这个亮点变得更亮。因为图像中的边缘就是那些灰度发生跳变的区域，所以拉普拉斯锐化模板在边缘检测中很有用。一般增强技术对于陡峭的边缘和缓慢变化的边缘很难确定其边缘线的位置。但此算子却可用二次微分正峰和负峰之间的过零点来确定，对孤立点或端点更为敏感，因此特别适用于以<strong>突出图像中的孤立点、孤立线或线端点为目的的场合</strong>。同梯度算子一样，拉普拉斯算子也会增强图像中的噪声，有时用拉普拉斯算子进行边缘检测时，可将图像先进行<strong>平滑处理</strong>。</p></blockquote><h2 id="代码">代码</h2><p>在OpenCV内使用函数cv2.Laplacian()实现Laplacian算子的计算，该函数的语法格式为：</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dst = cv2.<span class="hljs-constructor">Laplacian( <span class="hljs-params">src</span>, <span class="hljs-params">ddepth</span>[, <span class="hljs-params">ksize</span>[, <span class="hljs-params">scale</span>[, <span class="hljs-params">delta</span>[, <span class="hljs-params">borderType</span>]]]] )</span><br></code></pre></td></tr></tbody></table></figure><p>式中：<br>● dst代表目标图像。<br>● src代表原始图像。<br>● ddepth代表目标图像的深度。<br>● ksize代表用于计算二阶导数的核尺寸大小。该值必须是正的奇数。<br>● scale代表计算Laplacian值的缩放比例因子，该参数是可选的。默认情况下，该值为1，表示不进行缩放。<br>● delta代表加到目标图像上的可选值，默认为0。<br>● borderType : 用于推断图像外部像素的边界模式，一般是DORDER_DEFAULT,不支持BORDER_WRAP.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br>img = cv2.imread(<span class="hljs-string">"img.png"</span>,<span class="hljs-number">0</span>)<br>laplacian = cv2.Laplacian(img,cv2.CV_64F)<br>laplacian = cv2.convertScaleABs(laplacian)<br>cv2.imshow(img)<br>cv2.imshow(laplacian)<br></code></pre></td></tr></tbody></table></figure><p>原图<br><img src="https://picture.mulindya.com/laplace-pic4.png" alt=""><br>处理之后<br><img src="https://picture.mulindya.com/laplace-pic5.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer22 链表中倒数第k个节点</title>
      <link href="/2021/08/20/leetcode/leetcode-offer22/"/>
      <url>/2021/08/20/leetcode/leetcode-offer22/</url>
      
        <content type="html"><![CDATA[<blockquote><p>链表中倒数第k个节点</p></blockquote><h2 id="题目">题目</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></tbody></table></figure><h2 id="题解">题解</h2><p>一种方法是先确定链表的长度，然后再移动对应的结点个数。那么就需要O(2n)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span><br>        y = x = head<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span>(x):<br>            cnt += <span class="hljs-number">1</span><br>            x = x.<span class="hljs-built_in">next</span><br>        t = cnt - k<br>        <span class="hljs-keyword">while</span>(t):<br>            y = y.<span class="hljs-built_in">next</span><br>            t -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></tbody></table></figure><p>使用快慢指针，使得x与y相距k元素，然后x遍历到最后，y就可以得到对应的结果。此时只需要O(n)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span><br>        y = x = head<br>        <span class="hljs-keyword">while</span>(x):<br>            <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>):y = y.<span class="hljs-built_in">next</span><br>            x = x.<span class="hljs-built_in">next</span><br>            k -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> y<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Self-awareness</title>
      <link href="/2021/08/19/english/self-aware/"/>
      <url>/2021/08/19/english/self-aware/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote><p><a href="https://paper.mulindya.com/Self-awareness.pdf">https://paper.mulindya.com/Self-awareness.pdf</a></p><iframe src="/js/pdfjs_old/web/viewer.html?file=https://paper.mulindya.com/Self-awareness.pdf" width="100%" height="600"></iframe>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer29 顺时针打印矩阵</title>
      <link href="/2021/08/19/leetcode/leetcode-offer29/"/>
      <url>/2021/08/19/leetcode/leetcode-offer29/</url>
      
        <content type="html"><![CDATA[<blockquote><p>顺时针打印矩阵</p></blockquote><h2 id="题目">题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><h2 id="题解">题解</h2><p>一种是对数组进行常规操作，安装题目要求进行遍历判断。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spiralOrder</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> matrix: <span class="hljs-keyword">return</span> []<br>        l, r, t, b, res = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span>, []<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>): res.append(matrix[t][i]) <span class="hljs-comment"># left to right</span><br>            t += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> t &gt; b: <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t, b + <span class="hljs-number">1</span>): res.append(matrix[i][r]) <span class="hljs-comment"># top to bottom</span><br>            r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &gt; r: <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r, l - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>): res.append(matrix[b][i]) <span class="hljs-comment"># right to left</span><br>            b -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> t &gt; b: <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b, t - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>): res.append(matrix[i][l]) <span class="hljs-comment"># bottom to top</span><br>            l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &gt; r: <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> res<br><br></code></pre></td></tr></tbody></table></figure><p>第二种是采用相关的方法，<code>pop(0)</code>可以弹出第一个元素。使用$zip(<em>)$相当于对矩阵转置。<code>list(zip(*matrix))[::-1]</code>就是对矩阵逆旋转90度。zip和zip(</em>)也是一对逆操作；前者表示压缩，后者表示解压。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spiralOrder</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        res = []<br>        <span class="hljs-keyword">while</span> matrix:<br>            res += matrix.pop(<span class="hljs-number">0</span>)<br>            matrix = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*matrix))[::-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></tbody></table></figure><blockquote><p>pop &amp; zip知识参考</p><p><a href="https://blog.csdn.net/zhanshen112/article/details/90341177">https://blog.csdn.net/zhanshen112/article/details/90341177</a></p><p><a href="https://www.cnblogs.com/Aurora-Twinkle/p/8660778.html">https://www.cnblogs.com/Aurora-Twinkle/p/8660778.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer15 二进制中1的个数</title>
      <link href="/2021/08/19/leetcode/leetcode-offer15/"/>
      <url>/2021/08/19/leetcode/leetcode-offer15/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二进制中1的个数</p></blockquote><h2 id="题目">题目</h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。<br>提示：</p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的&nbsp;示例 3&nbsp;中，输入表示有符号整数 -3。</li></ul><h3 id="示例-1：">示例 1：</h3><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：n = <span class="hljs-number">11</span> (控制台输入 <span class="hljs-number">00000000000000000000000000001011</span>)<br>输出：<span class="hljs-number">3</span><br>解释：输入的二进制串 <span class="hljs-number">00000000000000000000000000001011</span>&nbsp;中，共有三位为 '1'。<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：n = <span class="hljs-number">128</span> (控制台输入 <span class="hljs-number">00000000000000000000000010000000</span>)<br>输出：<span class="hljs-number">1</span><br>解释：输入的二进制串 <span class="hljs-number">00000000000000000000000010000000</span>&nbsp;中，共有一位为 '1'。<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-3：">示例 3：</h3><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n =<span class="hljs-number"> 4294967293 </span>(控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：输入的二进制串<span class="hljs-number"> 11111111111111111111111111111101 </span>中，共有<span class="hljs-number"> 31 </span>位为 '1'。<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>输入必须是长度为 32 的 二进制串 。</li></ul><h2 id="题解">题解</h2><p>第一种方式是采用内置的bin函数，将n转化为二进制格式。然后统计其字符串的1的个数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        s = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(n))<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-string">'1'</span>):<br>                cnt+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></tbody></table></figure><p>第二种方法是采用移位操作<code>&lt;&lt;</code>和按位与<code>&amp;</code>对输入的数字进行统计。如：11 &amp; 8 = 8（1011 &amp; 100 = 100）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>       cnt = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">if</span>(n &amp; (<span class="hljs-number">1</span> &lt;&lt; i)))<br>       <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></tbody></table></figure><p><font color="hotpink">下面这个就很妙了</font></p><p>第三种方法 利用 <code>n &amp;（n-1）</code></p><p>(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1。<br>n &amp; (n - 1) 解析： 二进制数字 n 最右边的 1变成 0，其余不变。<br>利用此特性每次循环可以消去一个1</p><p><img src="https://picture.mulindya.com/leetcode-offer15pic1.png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingWeight</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> n:<br>            res += <span class="hljs-number">1</span><br>            n &amp;= n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 变量 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer20 表示数值的字符串</title>
      <link href="/2021/08/19/leetcode/leetcode-offer20/"/>
      <url>/2021/08/19/leetcode/leetcode-offer20/</url>
      
        <content type="html"><![CDATA[<blockquote><p>表示数值的字符串</p></blockquote><h2 id="题目">题目</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个&nbsp;小数&nbsp;或者&nbsp;整数</li><li>（可选）一个&nbsp;‘e’&nbsp;或&nbsp;‘E’&nbsp;，后面跟着一个&nbsp;整数</li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li><p>（可选）一个符号字符（‘+’ 或 ‘-’）</p></li><li><p>下述格式之一：</p><ol><li>至少一位数字，后面跟着一个点 ‘.’</li><li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li><li>一个点 ‘.’ ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（‘+’ 或 ‘-’）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li></ul><p>部分非数值列举如下：</p><ul><li>[“12e”, “1a3.14”, “1.2.3”, “±5”, “12e+5.4”]</li></ul><h3 id="示例-1：">示例 1：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"0"</span><br>输出：<span class="hljs-literal">true</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"e"</span><br>输出：<span class="hljs-literal">false</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-3：">示例 3：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"."</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-4：">示例 4：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">"    .1  "</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>1 &lt;= s.length &lt;= 20</li><li>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-’ ，空格 ’ ’ 或者点 ‘.’ 。</li></ul><h2 id="题解">题解</h2><h3 id="解题思路">解题思路</h3><p>本题解决方案是有限状态自动机。根据字符类型和合法数值的特点，定义状态，再画出状态转移图。</p><h4 id="字符类型">字符类型</h4><p>空格:’ ‘，数字:d，正负号:s，小数点:’.'，幂符号：e</p><h4 id="状态定义">状态定义</h4><p>从左到右可以定义为</p><p>0.左边的<code>空格</code></p><ol><li>E之前的<code>正负号</code></li><li>小数点前的<code>数字</code></li><li>小数点，小数点之后的<code>数字</code></li><li>小数点前为空格，<code>小数点</code>，小数点后为数字</li><li><code>幂符号</code></li><li>幂符号之后的<code>正负号</code></li><li>幂符号之后的<code>数字</code></li><li>结尾的<code>空格</code></li></ol><p><img src="https://picture.mulindya.com/leetcode-offer20-pic1.png" alt=""></p><h4 id="结束状态">结束状态</h4><p>正常的结束状态有2，3，7，8</p><h3 id="算法流程">算法流程</h3><h4 id="初始化">初始化</h4><h5 id="1，状态转移表status">1，状态转移表status</h5><p>$states[i]$表示所处的状态，$i$为所处的状态表示，$states[i]$使用哈希表存储从i状态到可转移的状态；使用键值对来表示$(key,value)$：若输入$key$，可从状态$i$转移至状态$value$.</p><p>当前状态p：初始状态为0</p><h5 id="2，转移循环">2，转移循环</h5><p>还需要<strong>记录字符类型</strong>t，遍历字符串的每个字符c</p><ul><li>当 c 为正负号时，执行 t = ‘s’ ;</li><li>当 c 为数字时，执行 t = ‘d’ ;</li><li>当 c 为 e , E 时，执行 t = ‘e’ ;</li><li>当 c 为 . , 空格 时，执行 t = c （即用字符本身表示字符类型）;</li><li>否则，执行 t = ‘?’ ，代表为不属于判断范围的非法字符，后续直接返回 false。</li></ul><p><strong>终止条件</strong>： 若字符类型 t不在哈希表  $states[p]$ 中，说明无法转移至下一状态，因此直接返回 False 。<br><strong>状态转移</strong>： 状态 p 转移至 $states[p][t]$。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        states = [<br>            { <span class="hljs-string">' '</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'s'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'.'</span>: <span class="hljs-number">4</span> }, <span class="hljs-comment"># 0. start with 'blank'</span><br>            { <span class="hljs-string">'d'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'.'</span>: <span class="hljs-number">4</span> } ,                <span class="hljs-comment"># 1. 'sign' before 'e'</span><br>            { <span class="hljs-string">'d'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'.'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">' '</span>: <span class="hljs-number">8</span> }, <span class="hljs-comment"># 2. 'digit' before 'dot'</span><br>            { <span class="hljs-string">'d'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">' '</span>: <span class="hljs-number">8</span> },         <span class="hljs-comment"># 3. 'digit' after 'dot'</span><br>            { <span class="hljs-string">'d'</span>: <span class="hljs-number">3</span> },                         <span class="hljs-comment"># 4. 'digit' after 'dot' (‘blank’ before 'dot')</span><br>            { <span class="hljs-string">'s'</span>: <span class="hljs-number">6</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">7</span> },                 <span class="hljs-comment"># 5. 'e'</span><br>            { <span class="hljs-string">'d'</span>: <span class="hljs-number">7</span> },                         <span class="hljs-comment"># 6. 'sign' after 'e'</span><br>            { <span class="hljs-string">'d'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">' '</span>: <span class="hljs-number">8</span> },                 <span class="hljs-comment"># 7. 'digit' after 'e'</span><br>            { <span class="hljs-string">' '</span>: <span class="hljs-number">8</span> }                          <span class="hljs-comment"># 8. end with 'blank'</span><br>        ]<br>        p = <span class="hljs-number">0</span>                           <span class="hljs-comment"># start with state 0</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">'0'</span> &lt;= c &lt;= <span class="hljs-string">'9'</span>: t = <span class="hljs-string">'d'</span> <span class="hljs-comment"># digit</span><br>            <span class="hljs-keyword">elif</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">"+-"</span>: t = <span class="hljs-string">'s'</span>     <span class="hljs-comment"># sign</span><br>            <span class="hljs-keyword">elif</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">"eE"</span>: t = <span class="hljs-string">'e'</span>     <span class="hljs-comment"># e or E</span><br>            <span class="hljs-keyword">elif</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">". "</span>: t = c       <span class="hljs-comment"># dot, blank</span><br>            <span class="hljs-keyword">else</span>: t = <span class="hljs-string">'?'</span>               <span class="hljs-comment"># unknown</span><br>            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> states[p]: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            p = states[p][t]<br>        <span class="hljs-keyword">return</span> p <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 有限状态机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 有限状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer21 调整数组顺序使奇数位于偶数前面</title>
      <link href="/2021/08/18/leetcode/leetcode-offer21/"/>
      <url>/2021/08/18/leetcode/leetcode-offer21/</url>
      
        <content type="html"><![CDATA[<blockquote><p>调整数组顺序使奇数位于偶数前面</p></blockquote><h2 id="题目">题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">1,3,2,4</span>] <br>注：[<span class="hljs-number">3,1,2,4</span>] 也是正确的答案之一。<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= nums.length &lt;= 50000</li><li>1 &lt;= nums[i] &lt;= 10000</li></ul><h2 id="题解">题解</h2><p>python的list的常规操作。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        odd = []<br>        even = []<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>):<br>                odd.append(x)<br>            <span class="hljs-keyword">else</span>:<br>                even.append(x)<br>        <span class="hljs-keyword">return</span> odd+even<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer28 对称的二叉树</title>
      <link href="/2021/08/18/leetcode/leetcode-offer28/"/>
      <url>/2021/08/18/leetcode/leetcode-offer28/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对称的二叉树</p></blockquote><h2 id="题目">题目</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p><p>1<br>&nbsp; &nbsp;/ <br>&nbsp; 2 &nbsp; 2<br>&nbsp;/ \ / <br>3 &nbsp;4 4 &nbsp;3<br>但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>1<br>&nbsp; &nbsp;/ <br>&nbsp; 2 &nbsp; 2<br>&nbsp; &nbsp;\ &nbsp; <br>&nbsp; &nbsp;3 &nbsp; &nbsp;3</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 节点个数 &lt;= 1000</li></ul><h2 id="题解">题解</h2><p>如果root为空就直接返回True，然后判断其左右子树是否为镜像结构。如果两个子节点为空则为真，如果一空则为假，然后分别判断其对称结构。 <code>judge(A.left,B.right) and judge(A.right,B.left)</code> 注意是镜像因此左右时相反的呢</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSymmetric</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judge</span>(<span class="hljs-params">A,B</span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (A <span class="hljs-keyword">or</span> B): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (A <span class="hljs-keyword">and</span> B) <span class="hljs-keyword">or</span> (A.val!=B.val): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> judge(A.left,B.right) <span class="hljs-keyword">and</span> judge(A.right,B.left) <br>        <span class="hljs-keyword">return</span> judge(root.left,root.right)<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer26 树的子结构</title>
      <link href="/2021/08/18/leetcode/leetcode-offer26/"/>
      <url>/2021/08/18/leetcode/leetcode-offer26/</url>
      
        <content type="html"><![CDATA[<blockquote><p>树的子结构</p></blockquote><h2 id="题目">题目</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><p>3<br>&nbsp; &nbsp; / <br>&nbsp; &nbsp;4 &nbsp; 5<br>&nbsp; / <br>&nbsp;1 &nbsp; 2<br>给定的树 B：</p><p>4&nbsp;<br>&nbsp; /<br>&nbsp;1<br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 节点个数 &lt;= 10000</li></ul><h2 id="题解">题解</h2><p>python代码真的！好！简洁！</p><p><code>isSubStructure</code>的作用是先序查找A，B的匹配情况。而在内部会对匹配的<code>judgechildren(A,B)</code>进行判断，查看是否为其子结构。</p><p>如果B为空了则表示匹配成功。如果根节点不匹配或者A为空了就直接返回失败。如果可以继续判断，就继续判断对应的左右子树。</p><p><code>(judgechildren(A,B) or self.isSubStructure(A.left,B) or self.isSubStructure(A.right,B))</code> 判断AB两子树；先序判断左右子树，<code>注意这里是self.isSubStructure</code>进行递归哦~~</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubStructure</span>(<span class="hljs-params">self, A: TreeNode, B: TreeNode</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">judgechildren</span>(<span class="hljs-params">A,B</span>):</span> <span class="hljs-comment">#判断以AB为根节点的条件下，B是否为A的子结构</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(B): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> A) <span class="hljs-keyword">or</span> (A.val!=B.val): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> judgechildren(A.right,B.right) <span class="hljs-keyword">and</span> judgechildren(A.left,B.left)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(A <span class="hljs-keyword">and</span> B) <span class="hljs-keyword">and</span> (judgechildren(A,B) <span class="hljs-keyword">or</span> self.isSubStructure(A.left,B) <span class="hljs-keyword">or</span> self.isSubStructure(A.right,B))<br></code></pre></td></tr></tbody></table></figure><blockquote><p>bool(A and B)注意要转换为bool变量</p></blockquote><ul><li><p>时间复杂度为O(MN)</p></li><li><p>空间复杂度 O(M)： 当树 A和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A叶子节点，此时总递归深度为 M。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer14.2 剪绳子2</title>
      <link href="/2021/08/18/leetcode/leetcode-offer14-2/"/>
      <url>/2021/08/18/leetcode/leetcode-offer14-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>剪绳子2</p></blockquote><h2 id="题目">题目</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] .请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li><code>2 &lt;= n &lt;= 1000</code></li></ul><h2 id="题解">题解</h2><p>使用动态规划具体参照剪绳子1</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuttingRope</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,i):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],<span class="hljs-built_in">max</span>(j*(i-j),j*dp[i-j]))<br>        <span class="hljs-keyword">return</span> dp[n]%<span class="hljs-number">1000000007</span><br></code></pre></td></tr></tbody></table></figure><p>但是这种方式时间复杂度较大。</p><p>步骤如下：(数学可以证明尽量分成多的3)<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">参见题解</a></p><ul><li>如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1</li><li>如果 n == 4，返回4</li><li>如果 n &gt; 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段；每次乘法操作后记得取余就行<br>以上2和3可以合并</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuttingRope</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span><br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">4</span>: <span class="hljs-comment"># 找寻尽量多的3</span><br>            res = res * <span class="hljs-number">3</span> % <span class="hljs-number">1000000007</span><br>            n -= <span class="hljs-number">3</span><br>        <span class="hljs-keyword">return</span> res * n % <span class="hljs-number">1000000007</span> <span class="hljs-comment">#乘以剩余的</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer14.1 剪绳子1</title>
      <link href="/2021/08/17/leetcode/leetcode-offer14-1/"/>
      <url>/2021/08/17/leetcode/leetcode-offer14-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>剪绳子</p></blockquote><h2 id="题目">题目</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><h4 id="示例-1：">示例 1：</h4><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1<br></code></pre></td></tr></tbody></table></figure><h4 id="示例-2：">示例 2：</h4><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36<br></code></pre></td></tr></tbody></table></figure><h5 id="提示：">提示：</h5><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><h4 id="题解">题解</h4><p>该题采用动态规划比较好理解，dp[i]表示长度为i的绳子分成m的最大乘积。j表示第一段的长度，遍历j的取值（可以直接从2开始），在剩余的i-j（<strong>缩小范围</strong>）的长度选择不切分或者最大乘积，即dp[i][j] = max(j*(i-j),j*dp[i-j])。<strong>但是实际上“【j】”并不关心</strong>，因此可以与dp[i]比较,选择最大的更新dp[i]即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cuttingRope</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        dp = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 表示长度为n的绳子得到的最大乘积</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,i): <span class="hljs-comment"># 第一段</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],<span class="hljs-built_in">max</span>(j*(i-j),j*dp[i-j])) <br>                <span class="hljs-comment">#向前获取信息，在选定j之后，注意还要比较dp[i]本身，以及在第一段j的基础上剩下的是否切</span><br>        <span class="hljs-keyword">return</span> dp[n]<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer07 重建二叉树</title>
      <link href="/2021/08/17/leetcode/leetcode-offer07/"/>
      <url>/2021/08/17/leetcode/leetcode-offer07/</url>
      
        <content type="html"><![CDATA[<blockquote><p>重建二叉树</p></blockquote><h2 id="题目">题目</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h3 id="示例-1：">示例 1：</h3><p><img src="https://picture.mulindya.com/leetcode-offer07-tree.jpg" alt="img"></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">Input: <span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>], <span class="hljs-attr">inorder</span> = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]<br>Output: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Input: preorder = <span class="hljs-comment">[-1]</span>, inorder = <span class="hljs-comment">[-1]</span><br>Output: <span class="hljs-comment">[-1]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 节点个数 &lt;= 5000</li></ul><h2 id="题解">题解</h2><p>使用闭包函数，构建对应区域的树，返回根节点。关键步骤是查找到rootindex在中序遍历中的位置，然后分别构建对应的子树。在查找时可以先建立哈希表，使用字典和枚举结合构建flag <code>flag = {ele:i for i,ele in enumerate(inorder)}</code>。可以减少执行时间的开销。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span>(<span class="hljs-params">self, preorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], inorder: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; TreeNode:</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">rootindex,ins,ine</span>):</span><br>            <span class="hljs-keyword">if</span>(ins&gt;ine): <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            root = TreeNode(preorder[rootindex])<br>            <span class="hljs-comment"># t = ins</span><br>            <span class="hljs-comment"># while(inorder[t]!=preorder[rootindex]):t+=1</span><br>            t = flag[preorder[rootindex]]<br>            root.left = func(rootindex+<span class="hljs-number">1</span>,ins,t-<span class="hljs-number">1</span>)<br>            root.right = func(rootindex+t-ins+<span class="hljs-number">1</span>,t+<span class="hljs-number">1</span>,ine)<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-comment"># 构建哈希表 在查找时更方便</span><br>        flag = {ele:i <span class="hljs-keyword">for</span> i,ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(inorder)} <span class="hljs-comment">#使用字典构建</span><br>        root = func(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(inorder)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度消失&amp;梯度爆炸</title>
      <link href="/2021/08/17/deep_learning/gradient-exp/"/>
      <url>/2021/08/17/deep_learning/gradient-exp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文探讨深度学习中经常提到的概念–梯度消失和梯度爆炸 。他们是影响模型收敛，学习好坏的重要因素。对此现象也提出了很多对应的解决方案。我们来大致做一个总结，对其概念，原因和相关的解决方案进行探讨叭~~</p></blockquote><h2 id="梯度爆炸-梯度消失">梯度爆炸&amp;梯度消失</h2><p>梯度爆炸就是在梯度更新的时候偏导数很大，导致更新参数无法收敛到最值（总是跳到其他不好的地方）。</p><p>梯度消失就是在梯度更新的时候偏导数很小，导致更新参数无法收敛到最值（动不了）。<br>$$<br>w_1=w_1− \alpha \frac{∂J(w)}{∂w1}<br>$$</p><p>$$<br>w_2=w_2− \alpha \frac{∂J(w)}{∂w2}<br>$$</p><p><img src="https://picture.mulindya.com/gradient-exp-pic1.png" alt=""></p><h2 id="梯度消失和梯度爆炸原因">梯度消失和梯度爆炸原因</h2><ul><li><p>训练方式：网络训练时采用反向传播的方式，会使用链式求导法则，因此对激活函数求导时，如果权重乘以激活函数导数此部分大于1，那么当层数很多时，求出的梯度更新将以指数的形式增加，则会梯度爆炸。如果此部分小于1，则随着层数增多，求出的梯度会指数衰减，则会梯度消失。</p></li><li><p>激活函数：如果选用sigmoid，$S(x) = \frac{1}{1+e^{-x}}$ ，而其导数 $S’(x) = \frac{e<sup>{-x}}{(1+e</sup>{-x})^2}=S(x)(1-S(x))$ ，其梯度不会超过0.25。</p></li><li><p>权重初始值：因此一个均值为0标准差为1的高斯分布初始化参数很容易发生梯度消失，因为权重集中在-1到1之间。如果初始化比较大的值</p></li><li><p>根据链式求导和反向传播，我们很容易得出，其中C是代价函数</p><p><img src="https://picture.mulindya.com/gradient-exp-pic2.png" alt=""></p><p><img src="https://picture.mulindya.com/gradient-exp-pic3.png" alt=""></p></li></ul><h2 id="解决方案">解决方案</h2><h3 id="1，采用好的参数初始化方法。比如He方法">1，采用好的参数初始化方法。比如<a href="https://blog.csdn.net/u010505915/article/details/106608922/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.base&amp;spm=1001.2101.3001.4242">He方法</a></h3><ol><li>前向传播的时候, 每一层的卷积计算结果的方差为1.</li><li>反向传播的时候, 每一 层的继续往前传的梯度方差为1(因为每层会有两个梯度的计算, 一个用来更新当前层的权重, 一个继续传播, 用于前面层的梯度的计算.)</li></ol><h3 id="2，梯度剪切–梯度爆炸">2，梯度剪切–梯度爆炸</h3><p>梯度裁剪是解决<strong>梯度爆炸</strong>的一种高效的方法，这里介绍梯度裁剪（Gradient Clipping）的方法，对梯度进行裁剪，论文提出对梯度的L2范数进行裁剪，也就是所有参数偏导数的平方和再开方。<br>$$<br>g_1=\frac{∂J(w)}{∂w1}<br>$$</p><p>$$<br>g_2=\frac{∂J(w)}{∂w2}<br>$$</p><p>设定裁剪阈值为 C = max_norm，$\Vert g\Vert_2= \sqrt{g<sup>2_1+g</sup>2_2}$</p><p>当$\Vert g\Vert_2$大于c时：</p><p>$$<br>g = \frac{c}{\Vert g \Vert_2} \cdot g<br>$$<br>当$\Vert g\Vert_2$小于等于C时：g不变。其中，$\frac{c}{\Vert g \Vert_2}$是一个标量</p><h3 id="3，正则化–梯度爆炸">3，正则化–梯度爆炸</h3><p>​采用权重正则化，主要是通过对网络权重做正则来限制过拟合，同时，如果发生梯度爆炸，那么权值的范数就会变的非常大，反过来，通过限制正则化项的大小，也可以在一定程度上限制梯度爆炸的发生。比较常见的是l1正则，和l2正则，在各个深度框架中都有相应的API可以使用正则化，比如在pytorch中，若搭建网络的时候已经设置了正则化参数，则调用以下代码可以直接计算出正则损失。<br>​torch.optim集成了很多优化器，如SGD，Adadelta，Adam，Adagrad，RMSprop等，这些优化器自带的一个参数weight_decay，用于指定权值衰减率，相当于L2正则化中的λ参数，注意torch.optim集成的优化器只有L2正则化方法，你可以查看注释，参数weight_decay 的解析是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">weight_decay (<span class="hljs-built_in">float</span>, optional): weight decay (L2 penalty) (default: <span class="hljs-number">0</span>)<br>optimizer = optim.Adam(model.parameters(),lr=learning_rate,weight_decay=<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></tbody></table></figure><p>loss计算公式<br>$$<br>Loss = (y-W<sup>Tx)</sup>2+\alpha {\Vert W \Vert}^2<br>$$</p><h3 id="4，激活函数">4，激活函数</h3><h4 id="1-ReLU函数：">1.ReLU函数：</h4><p>如果激活函数的导数为1，那么就不存在梯度消失爆炸的问题了，每层的网络都可以得到相同的更新速度，ReLU就这样应运而生。</p><p>ReLU的主要贡献在于：</p><p><img src="https://picture.mulindya.com/gradient-exp-pic4.png" alt=""></p><h5 id="优点">优点</h5><p>解决了梯度消失、爆炸的问题。<br>计算方便，计算速度快。<br>加速了网络的训练。</p><h5 id="缺点：">缺点：</h5><p>由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）。<br>输出不是以0为中心的。</p><h4 id="2-LeakyReLU函数：">2.LeakyReLU函数：</h4><p>LeakyReLU就是为了解决ReLU的0区间带来的影响，该函数输出对负值输入有很小的坡度，由于导数总是不为零，这能减少静默神经元的出现，允许基于梯度的学习（虽然会很慢），解决了ReLU函数进入负区间后，导致神经元不学习的问题。</p><p><img src="https://picture.mulindya.com/gradient-exp-pic5.png" alt=""></p><h4 id="3-ELU函数：">3.ELU函数：</h4><p><img src="https://picture.mulindya.com/gradient-exp-pic6.png" alt=""></p><ul><li><p>融合了sigmoid和ReLU，<strong>左侧具有软饱和性，右侧无饱和性</strong>。</p></li><li><p>右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱能够让ELU对输入变化或噪声更鲁棒。</p></li><li><p>ELU的输出均值接近于零，所以收敛速度更快，但相对于LeakyReLU来说，计算要更耗时间一些。</p></li></ul><p><font size="3" color="BlueViolet">小知识：</font></p><blockquote><p>梯度饱和常常是和激活函数相关的，比如sigmod和tanh就属于典型容易进入梯度饱和区的函数，即自变量进入某个区间后，梯度变化会非常小，表现在图上就是函数曲线进入某些区域后，越来越趋近一条直线，梯度变化很小，梯度饱和会导致训练过程中梯度变化缓慢，从而造成模型训练缓慢</p></blockquote><h3 id="4，Batch-Normalization">4，Batch Normalization</h3><p>BN是深度学习发展以来提出的最重要的成果之一了，目前已经被广泛的应用到了各大网络中，具有加速网络收敛速度，提升训练稳定性的效果，**BN本质上是解决反向传播过程中的梯度问题。**BN全名是Batch Normalization，简称BN，即批规范化，<strong>通过规范化操作将输出信号x规范化保证网络的稳定性。</strong><br>反向传播式子中有w的存在，所以w的大小影响了梯度的消失和爆炸，<strong>BN就是通过对每一层的输出规范为均值和方差一致的方法</strong>，消除了w带来的放大缩小的影响，进而解决梯度消失和爆炸的问题，或者可以理解为BN将输出从饱和区拉倒了非饱和区。<br>有关Batch Normalization详细的内容可以参考这篇博客： <a href="http://blog.csdn.net/qq_25737169/article/details/79048516">Batch Normalization</a></p><h3 id="5-残差结构">5,残差结构</h3><p>事实上，就是残差网络的出现导致了image net比赛的终结，自从残差提出后，几乎所有的深度网络都离不开残差的身影，相比较之前的几层，几十层的深度网络，在残差网络面前都不值一提，残差可以很轻松的构建几百层，一千多层的网络而不用担心梯度消失过快的问题，原因就在于残差的捷径（shortcut）部分。原理可参见：<a href="https://zhuanlan.zhihu.com/p/42706477">残差结构</a></p><h3 id="6，LSTM网络">6，LSTM网络</h3><p>LSTM是循环神经网络RNN的变体，全称是长短期记忆网络（long-short term memory networks），它是不那么容易发生梯度消失的，主要原因在于LSTM内部复杂的“门”结构，<strong>LSTM通过它内部的“门”可以接下来更新的时候“记住”前几次训练的“残留记忆”</strong>，因此，经常用于生成文本中。关于LSTM的原理详解后续再分析。<a href="https://zhuanlan.zhihu.com/p/32085405">LSTM</a></p><p><img src="https://picture.mulindya.com/gradient-exp-pic7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer27 二叉树的镜像</title>
      <link href="/2021/08/16/leetcode/leetcode-offer27/"/>
      <url>/2021/08/16/leetcode/leetcode-offer27/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二叉树的镜像</p></blockquote><h2 id="题目">题目</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p>​     4<br>2     7<br>1   3  6   9<br>镜像输出：</p><p>​     4<br>7     2<br>9   6 3   1</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span><br>输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 节点个数 &lt;= 1000</li></ul><h2 id="题解">题解</h2><p>如果为空树就返回空。然后保存左子树，翻转右子树后赋值为左节点，翻转左子树赋值为右节点。</p><p><strong>if not(root.left or root.right): return root #为单一节点就直接返回 可以省略，因为已经包含在内</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(root): <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        x = root.left<br>        root.left = self.mirrorTree(root.right)<br>        root.right = self.mirrorTree(x)<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer06 合并两个排序的链表</title>
      <link href="/2021/08/16/leetcode/leetcode-offer25/"/>
      <url>/2021/08/16/leetcode/leetcode-offer25/</url>
      
        <content type="html"><![CDATA[<blockquote><p>合并两个排序的链表</p></blockquote><h2 id="题目">题目</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 链表长度 &lt;= 1000</li></ul><h2 id="题解">题解</h2><p>如果直接用p = l.next  那么不能达到“指针”的效果。这样的操作对l没有影响，无法更新。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        l = ListNode(<span class="hljs-number">0</span>) <br>        p = l.<span class="hljs-built_in">next</span>     <br>        <span class="hljs-keyword">while</span>(l1 <span class="hljs-keyword">and</span> l2):<br>            <span class="hljs-keyword">if</span>(l1.val&gt;l2.val):<br>                p = l2<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                p = l1<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            p = p.<span class="hljs-built_in">next</span><br>        p = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2<br>        <span class="hljs-keyword">return</span> l.<span class="hljs-built_in">next</span><br></code></pre></td></tr></tbody></table></figure><p>正确方式，不能使用 p = p.next， 因为next是一个None值，改变p值并不会修改l对应的next。所以首先浅拷贝l，然后再直接改变内部的next，才能对应的改变l的内容。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        p = l = ListNode(<span class="hljs-number">0</span>) <span class="hljs-comment">#先指向同一块空间</span><br>        <span class="hljs-comment">#p = p.next      </span><br>        <span class="hljs-comment"># 不能使用p = p.next  因为next是一个None值改变p值并不会修改l对应的next。</span><br>        <span class="hljs-comment"># 所以首先浅拷贝，然后再直接改变内部的next，才能对应的改变l的内容</span><br>        <span class="hljs-keyword">while</span>(l1 <span class="hljs-keyword">and</span> l2):<br>            <span class="hljs-keyword">if</span>(l1.val&gt;l2.val):<br>                p.<span class="hljs-built_in">next</span> = l2<br>                l2 = l2.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                p.<span class="hljs-built_in">next</span> = l1<br>                l1 = l1.<span class="hljs-built_in">next</span><br>            p = p.<span class="hljs-built_in">next</span><br>        p.<span class="hljs-built_in">next</span> = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2<br>        <span class="hljs-keyword">return</span> l.<span class="hljs-built_in">next</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer13 机器人的运动范围</title>
      <link href="/2021/08/14/leetcode/leetcode-offer13/"/>
      <url>/2021/08/14/leetcode/leetcode-offer13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机器人的运动范围</p></blockquote><h2 id="题目">题目</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><h2 id="题解">题解</h2><h3 id="解法一-DFS">解法一 DFS</h3><ul><li>深搜+剪枝</li><li>优化技巧就是只判断右边和下边就行了，因为左和上是一定会在搜索的过程中被包括的</li></ul><p>​        <font color="purple">注意[[1]*n]*m 是浅拷贝复制（“=”复制）因此如果一个元素改变了，此列都会改变</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">movingCount</span>(<span class="hljs-params">self, m, n, k</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        """</span><br>        <br>        fflag = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]  <br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numsum</span>(<span class="hljs-params">i,j</span>):</span><br>            <span class="hljs-built_in">sum</span>=<span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span>(i):<br>                <span class="hljs-built_in">sum</span>+=(i%<span class="hljs-number">10</span>)<br>                i = i//<span class="hljs-number">10</span><br>            <span class="hljs-keyword">while</span>(j):<br>                <span class="hljs-built_in">sum</span>+=(j%<span class="hljs-number">10</span>)<br>                j = j//<span class="hljs-number">10</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">i,j</span>):</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> m&gt;i&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> n&gt;j&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (fflag[i][j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (numsum(i,j)&gt;k): <br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            fflag[i][j] = <span class="hljs-number">0</span><br>            <span class="hljs-comment"># return 1+dfs(i+1,j)+dfs(i-1,j)+dfs(i,j+1)+dfs(i,j-1)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+dfs(i+<span class="hljs-number">1</span>,j)+dfs(i,j+<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id="解法二-递推">解法二 递推</h3><h4 id="思路">思路</h4><p>考虑到方法一提到搜索的方向只需要朝下或朝右，我们可以得出一种递推的求解方法。</p><h4 id="算法">算法</h4><p>定义 <code>vis[i][j]</code> 为 <code>(i, j)</code> 坐标是否可达，如果可达返回 1，否则返回 0。</p><p>首先 (i, j) 本身需要可以进入，因此需要先判断 i 和 j 的数位之和是否大于 k ，如果大于的话直接设置 <code>vis[i][j]</code> 为不可达即可。</p><p>否则，前面提到搜索方向只需朝下或朝右，因此 (i, j) 的格子只会从 (i - 1, j) 或者 (i, j - 1) 两个格子走过来（不考虑边界条件），那么 <code>vis[i][j]</code> 是否可达的状态则可由如下公式计算得到：</p><p>即只要有一个格子可达，那么 (i, j) 这个格子就是可达的，因此我们只要遍历所有格子，递推计算出它们是否可达然后用变量 ans 记录可达的格子数量即可。</p><p>初始条件 <code>vis[i][j] = 1</code> ，递推计算的过程中注意边界的处理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">digitsum</span>(<span class="hljs-params">n</span>):</span><br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n:<br>        ans += n % <span class="hljs-number">10</span><br>        n //= <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">movingCount</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        vis = <span class="hljs-built_in">set</span>([(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">if</span> ((i - <span class="hljs-number">1</span>, j) <span class="hljs-keyword">in</span> vis <span class="hljs-keyword">or</span> (i, j - <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> vis) <span class="hljs-keyword">and</span> digitsum(i) + digitsum(j) &lt;= k:<br>                    vis.add((i, j))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(vis)<br></code></pre></td></tr></tbody></table></figure><h3 id="解法三">解法三</h3><h4 id="思路和算法">思路和算法</h4><p>我们将行坐标和列坐标数位之和大于 k 的格子看作障碍物，那么这道题就是一道很传统的搜索题目，我们可以使用广度优先搜索或者深度优先搜索来解决它，本文选择使用广度优先搜索的方法来讲解。</p><p>那么如何计算一个数的数位之和呢？我们只需要对数 x 每次对 10 取余，就能知道数 x 的个位数是多少，然后再将 x 除 10，这个操作等价于将 x 的十进制数向右移一位，删除个位数（类似于二进制中的 &gt;&gt; 右移运算符），不断重复直到 x 为 0 时结束。</p><p>同时这道题还有一个隐藏的优化：我们在搜索的过程中搜索方向可以缩减为向右和向下，而不必再向上和向左进行搜索。如下图，我们展示了 16 * 16 的地图随着限制条件 k 的放大，可行方格的变化趋势，每个格子里的值为行坐标和列坐标的数位之和，蓝色方格代表非障碍方格，即其值小于等于当前的限制条件 k。我们可以发现随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。而其他不连通的蓝色方格区域会随着 k 的增大而连通，且连通的时候也是由上方或左方的格子移动一步得到，因此我们可以将我们的搜索方向缩减为向右或向下。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">digitsum</span>(<span class="hljs-params">n</span>):</span><br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n:<br>        ans += n % <span class="hljs-number">10</span><br>        n //= <span class="hljs-number">10</span><br>    <span class="hljs-keyword">return</span> ans<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">movingCount</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span>, k: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br>        q = Queue()<br>        q.put((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>        s = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>            x, y = q.get()<br>            <span class="hljs-keyword">if</span> (x, y) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= x &lt; m <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= y &lt; n <span class="hljs-keyword">and</span> digitsum(x) + digitsum(y) &lt;= k:<br>                s.add((x, y))<br>                <span class="hljs-keyword">for</span> nx, ny <span class="hljs-keyword">in</span> [(x + <span class="hljs-number">1</span>, y), (x, y + <span class="hljs-number">1</span>)]:<br>                    q.put((nx, ny))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br></code></pre></td></tr></tbody></table></figure><h4 id="复杂度分析">复杂度分析</h4><h5 id="时间复杂度：O-mn">时间复杂度：O(mn)</h5><p>其中 m 为方格的行数，n 为方格的列数。考虑所有格子都能进入，那么搜索的时候一个格子最多会被访问的次数为常数，所以时间复杂度为 O(2mn)=O(mn)。</p><h5 id="空间复杂度：O-mn">空间复杂度：O(mn)</h5><p>其中 m 为方格的行数，n 为方格的列数。搜索的时候需要一个大小为 O(mn)的标记结构用来标记每个格子是否被走过。</p>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sobel算子</title>
      <link href="/2021/08/14/img_process/sobel/"/>
      <url>/2021/08/14/img_process/sobel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍Sobel算子，主要用于边缘检测；由于该算子引入了局部平均，对噪声有平滑作用，因此还可以消除噪声。</p></blockquote><h2 id="图像边缘与梯度">图像边缘与梯度</h2><p>在图像边缘，灰度值的变化较大，因此图像在此处的梯度值也较大。一般情况，图像梯度时计算图像的边缘信息。图像梯度严格来说时需要求导数，但是在图像计算上时使用像素值的差得到梯度的近似值。<br>图像强度的显著变化可分为：</p><ul><li>阶跃变化函数，即图像强度在不连续处的两边的像素灰度值有着显著的差异；</li><li>线条（屋顶）变化函数，即图像强度突然从一个值变化到另一个值，保持一较小行程后又回到原来的值。</li></ul><p><img src="https://picture.mulindya.com/sobel-pic1.png" alt=""></p><p>（a）（b）分别是阶跃函数和屋顶函数的二维图像；（c）（d）是阶跃和屋顶函数的函数图象；（e）（f）对应一阶倒数；（g）（h）是二阶倒数。</p><h2 id="Sobel算子">Sobel算子</h2><p>常用如下两个模板进行边缘检测，将Gx，Gy与图像卷积，即可得到横向和纵向的亮度差分近似值。</p>$$G_x = \begin{bmatrix} -1 &amp; 0 &amp; 1 \\ -2 &amp; 0 &amp; 2\\-1 &amp; 0 &amp; 1\end{bmatrix} \qquad G_y = \begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 0 &amp; 0 &amp; 0\\-1 &amp; -2 &amp; -1\end{bmatrix}$$<p>图像每一个像素的梯度可以使用$G = \sqrt{G<sup>2_x+G</sup>2_y}$来表示，梯度的方向使用$\Theta = arctan(\frac{G_y}{G_x})$。</p><p>还有另外一个比<code>Sobel</code>函数的近似效果更好的 <code>Scharr</code>函数，其内核矩阵如下:</p>$$G_x = \begin{bmatrix} -3 &amp; 0 &amp; 3 \\ -10 &amp; 0 &amp; 10 \\ -3 &amp; 0 &amp; 3\end{bmatrix} \qquad G_y = \begin{bmatrix} -3 &amp; -10 &amp; -3 \\ 0 &amp; 0 &amp; 0 \\ 3 &amp; 10 &amp; 3\end{bmatrix}$$<h2 id="代码使用">代码使用</h2><h3 id="cv2-Sobel">cv2.Sobel()</h3><p>Sobel算子依然是一种过滤器，只是其是带有方向的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.Sobel(src, ddepth, dx, dy[,ksize[, scale[, delta[, borderType]]]])<br></code></pre></td></tr></tbody></table></figure><ul><li>dst代表目标函数</li><li>src代表原始图像</li><li>ddpeth代表输出图像的深度 ，-1表示采用的是与原图像相同的深度。目标图像的深度必须大于等于原图像的深度；</li><li>dx代表x方向上的求导阶数 ，0表示这个方向上没有求导，一般为0、1、2。</li><li>dy代表y方向上的求导阶数，0表示这个方向上没有求导，一般为0、1、2。</li><li>ksize代表Sobel核的大小，该值为-1时，则会使用Scharr算子进行运算,一般选择为1、3、5、7</li><li>scale代表计算导数时所采用的缩放因子，默认为1，无缩放</li><li>delta代表加在目标图像dst上的值，该值是可选的，默认为0</li><li>borderType代表边界样式，这个参数默认值为cv2.BORDER_DEFAULT。</li></ul><blockquote><p>其中ddepth设计图像深度的概念：<br>图像深度是指存储每个像素值所用的位数，例如cv2.CV_8U，指的是8位无符号数，取值范围为0~255，超出范围则会被截断（截断指的是，当数值大于255保留为255，当数值小于0保留为0，其余不变）。</p><p>具体还有：CV_16S（16位无符号数），CV_16U（16位有符号数），CV_32F（32位浮点数），CV_64F（64位浮点数）等.</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-comment">#载入原图，图像深度为CV_8U</span><br>img_original=cv2.imread(<span class="hljs-string">'E:\ShannonT\\notebook workspace\\images\\4.28.9.jpg'</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#求X方向梯度，并且输出图像一个为CV_8U,一个为CV_64F</span><br>img_gradient_X_8U=cv2.Sobel(img_original,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>img_gradient_X_64F=cv2.Sobel(img_original,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#将图像深度改为CV_8U</span><br>img_gradient_X_64Fto8U=cv2.convertScaleAbs(img_gradient_X_64F)<br><span class="hljs-comment">#图像显示</span><br>cv2.imshow(<span class="hljs-string">'X_gradient_8U'</span>,img_gradient_X)<br>cv2.imshow(<span class="hljs-string">'X_gradient_64Fto8U'</span>,img_gradient_X_64Fto8U)<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><p><img src="https://picture.mulindya.com/sobel-pic2.png" alt=""></p><p><code>cv2.imshow()</code>的默认显示为8位无符号数，即[0,255]，因此在显示<code>CV_64F</code>的图像前使用了函数<code>cv2.convertScaleAbs()</code>将图像深度为<code>CV_64F</code>的梯度图像重新转化为<code>CV_8U</code>。</p><h3 id="cv2-convertScaleAbs">cv2.convertScaleAbs()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cv2.convert<span class="hljs-constructor">ScaleAbs(<span class="hljs-params">src</span>[,<span class="hljs-params">alpha</span>[,<span class="hljs-params">beta</span>]])</span><br></code></pre></td></tr></tbody></table></figure><p>先计算数组绝对值，后转化为8位无符号数</p><ul><li>src:输入图像（多维数组）</li><li>alpha:比例因子</li><li>beta:保存新图像（数组）前可以增加的值</li></ul><h3 id="归一化">归一化</h3><p>防止梯度大小被截断最简单的方法就是先将输入图像归一化（实际归一化的过程就已经实现了图像深度的转变）。在使用深度大于8U的格式之前将灰度先归一化，就不用<code>convertScaleAbs</code>转换了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#载入灰度原图，图像深度为CV_8U</span><br>img_original=cv2.imread(<span class="hljs-string">'E:\ShannonT\\notebook workspace\\images\\4.28.9.jpg'</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#原图归一化,实际图像深度已经变为CV_64F</span><br>img_standard=img_original/<span class="hljs-number">255</span><br><span class="hljs-comment">#采用灰度原图求X方向梯度</span><br>original_gradient_X_64F=cv2.Sobel(img_original,cv2.CV_64F,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>original_gradient_X_64Fto8U=cv2.convertScaleAbs(original_gradient_X_64F)<br><span class="hljs-comment">#采用归一化的图像求X方向梯度</span><br>standard_gradient_X=cv2.Sobel(img_standard,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">#图像显示</span><br>cv2.imshow(<span class="hljs-string">'original'</span>,img_original)<br>cv2.imshow(<span class="hljs-string">'original_X'</span>,original_gradient_X_64Fto8U)<br>cv2.imshow(<span class="hljs-string">'standard_X'</span>,standard_gradient_X)<br>cv2.waitKey()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><p><img src="https://picture.mulindya.com/sobel-pic3.png" alt=""></p><h3 id="cv2-addWeighted">cv2.addWeighted()</h3><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cv2.add<span class="hljs-constructor">Weighted(<span class="hljs-params">src1</span>, <span class="hljs-params">alpha</span>, <span class="hljs-params">src2</span>, <span class="hljs-params">beta</span>, <span class="hljs-params">gamma</span>[, <span class="hljs-params">dst</span>[, <span class="hljs-params">dtype</span>]])</span> → dst<br></code></pre></td></tr></tbody></table></figure><ul><li>src1 输入的第一个数组</li><li>alpha 第一个数组的权重</li><li>src2 输入的第二个数组（与第一个数组有相同的shape）</li><li>beta 第二个数组的权重</li><li>dst 输出的数组名称</li><li>gamma 计算和时所采用的缩放因子，默认为1，无缩放</li><li>dtype 输出图像的深度，-1表示和input相同</li><li></li></ul><blockquote><p>dst = src1 * alpha + src2 * beta + gamma;</p></blockquote><p>注意：由参数说明可以看出，被叠加的两幅图像必须是尺寸相同、类型相同的；并且，当输出图像array的深度为CV_32S时，这个函数就不适用了，这时候就会内存溢出或者算出的结果压根不对。</p><h3 id="边缘检测">边缘检测</h3><p>通过cv2.Sobel()我们可以轻松计算出X,Y方向的梯度大小，根据公式</p><p>$$<br>G = \sqrt{G<sup>2_x+G</sup>2_y}<br>$$<br>可以求出梯度图像，实际操作时，为了简化运算，我们使用公式</p><p>$$<br>G = \vert{G_x}\vert+\vert{G_y}\vert<br>$$</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#载入灰度原图，并且归一化</span><br>img_original=cv2.imread(<span class="hljs-string">'E:\ShannonT\\notebook workspace\\images\\4.28.9.jpg'</span>,<span class="hljs-number">0</span>)/<span class="hljs-number">255</span><br><span class="hljs-comment">#分别求X,Y方向的梯度</span><br>grad_X=cv2.Sobel(img_original,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>grad_Y=cv2.Sobel(img_original,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">#求梯度图像</span><br>grad=cv2.addWeighted(grad_X,<span class="hljs-number">0.5</span>,grad_Y,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>)<br>cv2.imshow(<span class="hljs-string">'gradient'</span>,grad)<br></code></pre></td></tr></tbody></table></figure><h2 id="官方说明">官方说明</h2><p>当年作者并没有公开发表过论文，仅仅是在一次博士生课题讨论会(1968)上提出(“A 3x3 Isotropic Gradient Operator for Image Processing”)，后在1973年出版的一本专著（“Pattern Classification and Scene Analysis”）的脚注里作为注释出现和公开的。</p><p>详细介绍，请参考以下内容。</p><iframe src="/js/pdfjs_old/web/viewer.html?file=https://paper.mulindya.com/An%20Isotropic%203x3%20Image%20Gradient%20Operator.pdf" width="100%" height="450"></iframe>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer06 从尾到头打印链表</title>
      <link href="/2021/08/14/leetcode/leetcode-offer06/"/>
      <url>/2021/08/14/leetcode/leetcode-offer06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从尾到头打印链表</p></blockquote><h2 id="题目">题目</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= 链表长度 &lt;= 10000</li></ul><h2 id="题解">题解</h2><p>遍历链表，直接插入到头位置。就可以直接输出了。或者采用递归，超级简洁，值得借鉴。注意if的条件和对应结果。（递归就从中间普适的节点开始考虑 然后补充边界细节）</p><p><font color="orange">return self.reversePrint( head.next ) + [ head.val ] if head else []</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reversePrint</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        """</span><br>        p=head<br>        result = []<br>        <span class="hljs-keyword">while</span>(p):<br>            result = [p.val]+result <span class="hljs-comment">#直接添加到前面</span><br>            p = p.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> result<br>        <span class="hljs-comment">#使用递归一条语句超级简洁 递归后一个元素+当前元素 如果当前为空则+【】 也是终止未知</span><br>        <span class="hljs-comment">#return self.reversePrint(head.next) + [head.val] if head else []</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer12 矩阵中的路径</title>
      <link href="/2021/08/14/leetcode/leetcode-offer12/"/>
      <url>/2021/08/14/leetcode/leetcode-offer12/</url>
      
        <content type="html"><![CDATA[<blockquote><p>矩阵中的路径</p></blockquote><h2 id="题目">题目</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://picture.mulindya.com/leetcode-offer12-pic1.jpg" alt=""></p><h3 id="示例-1：">示例 1：</h3><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"E"</span>],[<span class="hljs-string">"S"</span>,<span class="hljs-string">"F"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"S"</span>],[<span class="hljs-string">"A"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"E"</span>]], word = <span class="hljs-string">"ABCCED"</span><br>输出：true<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">board</span> = [[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>]], <span class="hljs-attr">word</span> = <span class="hljs-string">"abcd"</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h2 id="题解">题解</h2><p>循环遍历二维数组，以此为起点判断是否存在连续的字符串。在dfs中首先进行边界范围判断，以及此点是否满足要求，如果不满足要求直接返回假，为真则继续word判断之后的字符。如果以及是最后的字符就可以直接返回结果。<font color="purple">注意在判断k+1之前需要先mask掉自身的值，防止后续“路线返回”</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exist</span>(<span class="hljs-params">self, board, word</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type board: List[List[str]]</span><br><span class="hljs-string">        :type word: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        """</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">i,j,k</span>):</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(board)&gt;i&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (<span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])&gt;j&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> board[i][j]!=word[k]: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span> <br>            <span class="hljs-comment">#不匹配的情况</span><br>            <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word)-<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-comment">#不用继续判断</span><br>            board[i][j] = <span class="hljs-string">' '</span><br>            <span class="hljs-comment"># #注意不能直接返回 因为在处理邻近的内容会判断到自身，这是不允许的，所以先mask</span><br>            <span class="hljs-comment"># return dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1) </span><br>            res = dfs(i+<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> dfs(i-<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> dfs(i,j+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> dfs(i,j-<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) <br>            board[i][j] = word[k]<br>            <span class="hljs-keyword">return</span> res<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> dfs(i,j,<span class="hljs-number">0</span>): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-comment">#如果从ij开始找0之后的字符串找到则为真</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer11 旋转数组的最小数字</title>
      <link href="/2021/08/13/leetcode/leetcode-offer11/"/>
      <url>/2021/08/13/leetcode/leetcode-offer11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>旋转数组的最小数字</p></blockquote><h2 id="题目">题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h2 id="题解">题解</h2><p>将数组遍历一遍，遇到第一个非增序的元素即为最小值。复杂度为线性级别。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minArray</span>(<span class="hljs-params">self, numbers: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(numbers):<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        minitem = numbers[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(numbers)):<br>            <span class="hljs-keyword">if</span> numbers[i]&lt;numbers[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(minitem,numbers[i])<br>        <span class="hljs-keyword">return</span> minitem<br></code></pre></td></tr></tbody></table></figure><p>还可以使用二分法，将线性级别的复杂度降低到对数级别。</p><p><img src="https://picture.mulindya.com/leetcode-offer11-pic1.png" alt=""></p><p>最低点有特性：左边的所有元素都要比右边所有元素大。利用这个特性可以逐渐缩小范围。</p><p>中间元素和某个边界元素比较大小，来确定范围，<u>但是要注意两者相等时就没有确切的判断了</u>。可以直接用线性比较来替代。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minArray</span>(<span class="hljs-params">self, numbers: [<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> numbers[m] &gt; numbers[j]: i = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> numbers[m] &lt; numbers[j]: j = m<br>            <span class="hljs-keyword">else</span>: j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> numbers[i]<br></code></pre></td></tr></tbody></table></figure><p>实际上，当出现 nums[m] = nums[j] 时，一定有区间[i,m]内所有元素相等 或 区间 [m,j] 内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minArray</span>(<span class="hljs-params">self, numbers: [<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            m = (i + j) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> numbers[m] &gt; numbers[j]: i = m + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> numbers[m] &lt; numbers[j]: j = m<br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(numbers[i:j])<br>        <span class="hljs-keyword">return</span> numbers[i]<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 数组 </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献整理笔记</title>
      <link href="/2021/08/13/paper/paper-site/"/>
      <url>/2021/08/13/paper/paper-site/</url>
      
        <content type="html"><![CDATA[<blockquote><p>查找文献的网站<br><a href="https://www.thecvf.com/">https://www.thecvf.com/</a><br><a href="https://arxiv.org/list/cs/recent">https://arxiv.org/list/cs/recent</a><br><a href="https://www.researchgate.net/">https://www.researchgate.net/</a></p></blockquote><blockquote><p>超宝藏博主： <a href="https://www.zhihu.com/people/wang-jia-hao-53-3">科技猛兽</a><br>宝藏公众号： 极市平台<br>系列学习： <a href="https://zhuanlan.zhihu.com/p/348593638">VIT学习</a></p></blockquote><h3 id="微调技巧">微调技巧</h3><p><a href="https://paper.mulindya.com/Accurate%2C%20Large%20Minibatch%20SGD%20Training%20ImageNet%20in%201%20Hour.pdf"><strong>Accurate, Large Minibatch SGD Training ImageNet in 1 Hour.pdf</strong></a></p><p><a href="https://paper.mulindya.com/BITGeneral%20Visual%20Representation%20Learning.pdf"><strong>BIT : General Visual Representation Learning.pdf</strong></a></p><p><a href="https://paper.mulindya.com/Co-Tuning%20for%20Transfer%20Learning.pdf"><strong>Co-Tuning for Transfer Learning.pdf</strong></a></p><p><a href="https://paper.mulindya.com/EfficientNet%20Rethinking%20Model%20Scaling%20for%20Convolutional%20Neural%20Networks.pdf"><strong>EfficientNet Rethinking Model Scaling for Convolutional Neural Networks.pdf</strong></a></p><p><a href="https://paper.mulindya.com/He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.pdf"><strong>He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.pdf</strong></a></p><p><a href="https://paper.mulindya.com/Simple%20Copy-Paste%20is%20a%20Strong%20Data%20Augmentation%20Method.pdf"><strong>Simple Copy-Paste is a Strong Data Augmentation Method.pdf</strong></a></p><p><a href="https://paper.mulindya.com/Discriminative%20Feature%20Alignment%20Improving%20Transferability%20of.pdf"><strong>Discriminative Feature Alignment Improving Transferability of.pdf</strong></a></p><p><a href="https://paper.mulindya.com/Movement%20Pruning%20adaptive%20sparsity%20by%20fine-tuning.pdf"><strong>Movement Pruning adaptive sparsity by fine-tuning.pdf</strong></a></p><h3 id="FPN">FPN</h3><p><a href="https://paper.mulindya.com/Feature%20Pyramid%20Networks%20for%20Object%20Detection.pdf"><strong>Feature Pyramid Networks for Object Detection</strong></a>（FPN目标检测 解读https://zhuanlan.zhihu.com/p/36461718）</p><h3 id="Transformer">Transformer</h3><p><a href="https://paper.mulindya.com/Feature%20Pyramid%20Networks%20for%20Object%20Detection.pdf"><strong>Attention Is All You Need</strong></a> (讲解Attention机制)</p><p><a href="https://paper.mulindya.com/A%20Survey%20on%20Visual%20Transformer.pdf"><strong>A Survey of Transformers</strong></a>（Transformer的总结）</p><h3 id="VIT">VIT</h3><p><a href="https://paper.mulindya.com/A%20Survey%20on%20Visual%20Transformer.pdf"><strong>AN IMAGE IS WORTH 16X16 WORDS: TRANSFORMERS FOR IMAGE RECOGNITION AT</strong></a>（将transformer应用于图像分类）</p><p><a href="https://paper.mulindya.com/How%20to%20train%20your%20ViT.pdf"><strong>How to train your ViT? Data, Augmentation,and Regularization in Vision Transformers</strong></a>（训练技巧）</p><p><a href="https://paper.mulindya.com/Scaling%20Vision%20Transformers.pdf"><strong>Scaling Vision Transformers</strong></a>（精炼VIT）</p><p><a href="https://paper.mulindya.com/levit.pdf"><strong>LeViT: a Vision Transformer in ConvNet’s Clothing for Faster Inference</strong></a> （混合网络）</p><p><a href="https://paper.mulindya.com/End-to-End%20Semi-Supervised%20Object%20Detection%20with%20Soft%20Teacher.pdf"><strong>End-to-End Video Instance Segmentation with Transformers</strong></a>（使用transformer进行实例分割）</p><p><a href="https://paper.mulindya.com/A%20Survey%20on%20Visual%20Transformer.pdf"><strong>A Survey on Visual Transformer</strong></a> （总结）</p><h3 id="EfficientNet">EfficientNet</h3><p><a href="https://paper.mulindya.com/EfficientNet%20Rethinking%20Model%20Scaling%20for%20Convolutional%20Neural%20Networks.pdf"><strong>EfficientNet Rethinking Model Scaling for Convolutional Neural Networks.pdf</strong></a></p><h3 id="BIT">BIT</h3><p><a href="https://paper.mulindya.com/BITGeneral%20Visual%20Representation%20Learning.pdf"><strong>BIT : General Visual Representation Learning.pdf</strong></a></p><h3 id="YOLOv4">YOLOv4</h3><p><a href="https://paper.mulindya.com/yolo4.pdf"><strong>YOLOv4: Optimal Speed and Accuracy of Object Detection</strong></a></p><h3 id="PaDim">PaDim</h3><p><a href="https://paper.mulindya.com/PaDiM_a%20Patch%20Distribution%20Modeling%20Framework.pdf"><strong>PaDiM: a Patch Distribution Modeling Framework for Anomaly Detection and Localization</strong></a> (使用马氏距离)</p><p><a href="https://paper.mulindya.com/Semi-orthogonal%20Embedding%20for%20Efficient%20Unsupervised%20Anomaly%20Segmentation.pdf"><strong>Semi-orthogonal Embedding for Efficient Unsupervised Anomaly Segmentation</strong></a> （很多数学知识）</p><h3 id="Swin">Swin</h3><p><a href="https://paper.mulindya.com/Swin%20Transformer%20Hierarchical%20Vision%20Transformer%20using%20Shifted%20Windows.pdf"><strong>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows</strong></a></p><h3 id="其他">其他</h3><p>谷歌提出的使用MPL代替Transformer，CNN（<a href="https://zhuanlan.zhihu.com/p/370780575">也引发了一些争议</a>）</p><p><a href="https://paper.mulindya.com/MLP-Mixer_An%20all-MLP%20Architecture%20for%20Vision.pdf"><strong>MLP-Mixer: An all-MLP Architecture for Vision</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 文献 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fine-tuning的方法</title>
      <link href="/2021/08/13/deep_learning/fine-tuning/"/>
      <url>/2021/08/13/deep_learning/fine-tuning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>收集关于深度学习的调参的相关笔记，主要用于网络训练的微调。</p></blockquote><h3 id="训练技巧"><strong>训练技巧</strong></h3><p>1.要做<strong>梯度归一化</strong>,即算出来的梯度除以minibatch size</p><p>2.clip c(梯度裁剪): 限制最大梯度,其实是value = sqrt(w1^2 +w2^2….),如果value超过了阈值,就算一个衰减系数,让value的值等于阈值: 5,10,15</p><p><strong>3.防止过拟合</strong></p><p>​一般常用的防止过拟合方法有使用<strong>L1正则项、L2正则项、dropout、提前终止、数据集扩充等</strong>。如果模型在训练集上表现比较好但在测试集上表现欠佳可以选择增大L1或L2正则的惩罚力度（<strong>L2正则经验上首选1.0</strong>，超过10很少见），或<strong>增大dropout的随机失活概率</strong>（经验首选0.5）；或者当随着训练的持续在测试集上不增反降时，使用提前终止训练的方法。当然<strong>最有效的还是增大训练集的规模</strong>，实在难以获得新数据也可以使用数据集增强的方法，比如CV任务可以对数据集进行裁剪、翻转、平移等方法进行数据集增强，这种方法往往都会提高最后模型的测试精度。<br>dropout对小数据防止过拟合有很好的效果,值一般设为0.5,小数据上dropout+sgd。在大部分实验中，效果提升都非常明显.<strong>建议尝试</strong>。 dropout的位置比较有讲究, 对于RNN,建议放到输入-&gt;RNN与RNN-&gt;输出的位置.关于RNN如何用dropout,可以参考:<a href="https://link.zhihu.com/?target=http%3A//arxiv.org/abs/1409.2329">http://arxiv.org/abs/1409.2329</a>(Captain Jack令言:(不仅仅可以防止过拟合, 其实这相当于做人力成本最低的Ensemble, 当然, 训练起来会比没有Dropout的要慢一点, 同时网络参数你最好相应加一点, 对, 这会再慢一点).)</p><p><strong>4.超参</strong></p><p>​learning rate 最重要**，推荐了解 cosine learning rate 和 cyclic learning rate，其次是 <strong>batchsize 和 weight decay</strong>。当你的模型还不错的时候，可以试着做数据增广和改损失函数锦上添花了。(罗浩ZJU令言：随着网络训练的进行，学习率要逐渐降下来；网络性能越好，学习率要越小（即越需要微调而非粗调)；batchsize通常影响没那么大，塞满卡就行，除了特殊的算法需要batch大一点)<br>​adam,adadelta等,在小数据上,我这里实验的效果不如sgd, sgd收敛速度会慢一些，但是最终收敛后的结果，一般都比较好。<strong>如果使用sgd的话,可以选择从1.0或者0.1的学习率开始,隔一段时间,在验证集上检查一下,如果cost没有下降,就对</strong>学习率减半**. 我看过很多论文都这么搞,我自己实验的结果也很好. 当然,也可以先用ada系列先跑,最后快收敛的时候,更换成sgd继续训练.同样也会有提升.据说adadelta一般在分类问题上效果比较好，adam在生成问题上效果比较好。(Captain Jack令言：sgd adam 这些选择上, 看你个人选择. 一般对网络不是决定性的. 反正我无脑用sgd + momentum. ）</p><p>5.<strong>激活函数</strong><br>除了gate之类的地方,需要把输出限制成0-1之外,<strong>尽量不要用sigmoid</strong>,可以用tanh或者relu之类的激活函数.1. sigmoid函数在-4到4之外的区间梯度接近0，很容易造成梯度消失问题。2. 输入0均值，sigmoid函数的输出不是0均值的。（hzwer令言:虽然有至少十种激活函数，但在 Relu 外只推荐试一下 Swish。)</p><p>6.BN层具有加速训练速度，有效防止梯度消失与梯度爆炸，具有防止过拟合的效果，所以构建网络时最好要加上这个组件。(Captain Jack令言：batch normalization我一直没用, 虽然我知道这个很好, 我不用仅仅是因为我懒. 所以要鼓励使用batch normalization.）</p><p>7.如果你的模型包含全连接层（MLP），并且输入和输出大小一样，可以考虑将MLP替换成<strong>Highway Network</strong>,我尝试对结果有一点提升，建议作为最后提升模型的手段，原理很简单，就是给<strong>输出加了一个gate来控制信息的流动</strong>，详细介绍请参考论文: <a href="https://link.zhihu.com/?target=http%3A//arxiv.org/abs/1505.00387">http://arxiv.org/abs/1505.00387</a></p><p>8.来自@张馨宇的技巧：<strong>一轮加正则，一轮不加正则，反复进行。</strong></p><p><strong>9.Ensemble</strong><br>Ensemble是论文刷结果的终极核武器,深度学习中一般有以下几种方式<br>同样的参数,不同的初始化方式<br>不同的参数,通过cross-validation,选取最好的几组<br>同样的参数,模型训练的不同阶段，即不同迭代次数的模型。<br>不同的模型,进行线性融合. 例如RNN和传统模型.</p><p><strong>10.自动调参方法</strong><br>（1）Grid Search：其原理就像是在数组里找最大值。缺点是太费时间了，特别像神经网络，一般尝试不了太多的参数组合。<br>（2）Random Search：经验上，Random Search比Gird Search更有效。实际操作的时候，一般也是先用Gird Search的方法，得到所有候选参数，然后每次从中随机选择进行训练。另外Random Search往往会和由粗到细的调参策略结合使用，即在效果比较好的参数附近进行更加精细的搜索。<br>（3）Bayesian Optimization：贝叶斯优化，考虑到了不同参数对应的 实验结果值，因此更节省时间，贝叶斯调参比Grid Search迭代次数少， 速度快；而且其针对非凸问题依然稳健。</p><p><strong>11.Loss设计</strong><br>+ 一般来说分类就是Softmax, 回归就是L2的loss. 但是要注意loss的错误范围(主要是回归), 你预测一个label是10000的值, 模型输出0, 你算算这loss多大, 这还是单变量的情况下. 一般结果都是nan. 所以不仅仅输入要做normalization, 输出也要.<br>+ 多任务情况下, 各loss想法限制在一个量级上, 或者最终限制在一个量级上, 初期可以着重一个任务的loss。</p><h3 id="网络结构设计（关于SE"><strong>网络结构设计（关于SE)</strong></h3><p>SE在分类上是个涨点必备的工具，换言之，堆最高精度是一定要给每个block都加上它的，但是如果需要考虑时间，参数量和精度等的trade-off，无脑堆就没有意义了，这个时候应该要选择在合适的地方使用合适的模块。这个时候，<strong>推荐在block数量和添加SE上做权衡</strong>，即<strong>给部分blcok加上SE，同时砍掉一些block来加速</strong>，这样可以在精度差不多的情况下减少一些参数量。当然inference时间这个事需要看具体的应用平台对SE的实现，就是GAP和FC的速度，这就具体问题具体分析了。<strong>有余力有卡的人，可以迁移某种NAS方法来做这个的搜索。</strong><br>参考自：<br>你有哪些deep learning（rnn、cnn）调参的经验？ - 萧瑟的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/94816420">https://www.zhihu.com/question/41631631/answer/94816420</a><br>你有哪些deep learning（rnn、cnn）调参的经验？ - Towser的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/862075836">https://www.zhihu.com/question/41631631/answer/862075836</a><br>你有哪些deep learning（rnn、cnn）调参的经验？ - 罗浩.ZJU的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/216788968">https://www.zhihu.com/question/41631631/answer/216788968</a><br>你有哪些deep learning（rnn、cnn）调参的经验？ - 京东白条的回答 - 知乎 <a href="https://www.zhihu.com/question/41631631/answer/776852832">https://www.zhihu.com/question/4163</a></p><blockquote><p>所谓SE：SENet是Squeeze-and-Excitation Networks的简称，拿到了ImageNet2017分类比赛冠军，其效果得到了认可，其提出的SE模块思想简单，易于实现，并且很容易可以加载到现有的网络模型框架中。<em><u>SENet主要是学习了channel之间的相关性，筛选出了针对通道的注意力</u></em>，稍微增加了一点计算量，但是效果比较好。</p></blockquote><p>对于CNN网络来说，其核心计算是卷积算子，其通过卷积核从输入特征图学习到新特征图。从本质上讲，卷积是对一个局部区域进行特征融合，这包括空间上（H和W维度）以及通道间（C维度）的特征融合。</p><p><img src="https://picture.mulindya.com/fine-tuning-pic1.png" alt=""></p><p>卷积实际上是对<u>局部区域</u>进行的特征融合。 这也导致了普通卷积神经网络的感受野不大，当然你也可以设计出更多的通道特征来增加这个，但是这样做导致了计算量大大的增加。因此为了空间上融合更多特征融合，或者是提取多尺度空间信息。也提出了许多不同的方法如Inception网络的多分支结构。对于channel维度的特征融合，卷积操作基本上默认对输入特征图的所有channel进行融合。<u>而SENet网络的创新点在于关注channel之间的关系，希望模型可以自动学习到不同channel特征的重要程度</u>。为此，SENet提出了Squeeze-and-Excitation (SE)模块，如下图所示：</p><p><img src="https://picture.mulindya.com/fine-tuning-pic2.png" alt=""></p><h3 id="反面训诫">反面训诫</h3><p>1.1、一上来就自己动手写模型。<br>建议首先用<strong>成熟的开源项目及其默认配置</strong>（例如 Gluon 对经典模型的各种复现、各个著名模型作者自己放出来的代码仓库）在自己的数据集上跑一遍，在等程序运行结束的时间里仔细研究一下代码里的各种细节，最后再自己写或者改代码。</p><p>1.2、<strong>不推荐做人肉模型设计</strong>，比如把某层卷积改大一点，或者微调一下通道数。除非有特别 insight，不要自己乱设计新组件。</p><p>2、训 RNN 不加 gradient clipping，导致训练一段时间以后 loss 突然变成 Nan。</p><p>3、tying input &amp; output embedding（就是词向量层和输出 softmax 前的矩阵共享参数，在语言模型或机器翻译中常用）时学习率需要设置得非常小，不然容易 Nan。</p><p>4.1、在数据集很大的情况下，一上来就跑全量数据。建议先用 1/100、1/10 的数据跑一跑，对模型性能和训练时间有个底。</p><p>4.2认为网络层数越大越好。参数量什么的都不是大问题，在性能不丢的情况下，网络层数减到最小.（Captain Jack令言：你有95%概率不会使用超过40层的模型. ）</p><p>5、只喜欢漂亮的模型结构，瞧不起调参数的论文/实验报告，<strong>看论文时经常不看超参数设置等细节</strong>。殊不知在自己没有太多资源实验的情况下，实验报告类文章简直是业界良心！<br>NLP 领域主要推荐以下几篇：<br>Regularizing and Optimizing LSTM Language Models（LSTM 的训练技巧）<br>Massive Exploration of Neural Machine Translation Architectures（NMT 里各个超参的影响）<br>Training Tips for the Transformer Model（训练 Transformer 时会发生的各种现象）<br>RoBERTa: A Robustly Optimized BERT Pretraining Approach（BERT 预训练技巧，虽然跟大部分人没啥关系）<br>CV 我不算太熟，不过也可以勉强推荐几篇：</p><p><a href="https://arxiv.org/pdf/1706.02677.pdf">Training ImageNet in 1 Hour（大批量训练技巧）</a><br><a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/He_Bag_of_Tricks_for_Image_Classification_with_Convolutional_Neural_Networks_CVPR_2019_paper.pdf">Bag of Tricks for Image Classification with Convolutional Neural Networks（各种训练技巧集大成）</a><br><a href="https://arxiv.org/pdf/1905.11946.pdf">EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks（当前对参数利用最有效的 CNN）</a></p><p>6、对于loss这种受 batch size、sequence length 各种因素影响的数字，人是没有数感的，建议首先计算一下 per token loss（如果是多任务，可以每个任务单独算；类似地，某些 CV 任务可以计算 per pixel loss），心里有点感觉。<strong>脱离损失函数的形式谈学习率没有意义</strong>（例如单是对 batch size 求和或者取平均这个差异就会使梯度差成百上千倍）。<br>在确定初始学习率的时候，从一个很小的值（例如 1e-7）开始，然后**每一步指数增大学习率（例如扩大1.05 倍）进行训练。**训练几百步应该能观察到损失函数随训练步数呈对勾形，选择损失下降最快那一段的学习率即可。<br>(Captain Jack令言：<strong>观察loss胜于观察准确率</strong><br>准确率虽然是评测指标, 但是训练过程中还是要注意loss的. 你会发现有些情况下, 准确率是突变的, 原来一直是0, 可能保持上千迭代, 然后突然变1. 要是因为这个你提前中断训练了, 只有老天替你惋惜了. 而loss是不会有这么诡异的情况发生的, 毕竟优化目标是loss.<br>给NN一点时间, 要根据任务留给NN的学习一定空间. 不能说前面一段时间没起色就不管了. 有些情况下就是前面一段时间看不出起色, 然后开始稳定学习.）</p><p>7.1、优化器<strong>只推荐</strong> Momentum 和 Adam。在这些方面做尝试意义不大，如果性能提升反倒可能说明模型不成熟。</p><p>7.2、<strong>Adam 可以解决一堆奇奇怪怪的问题</strong>（有时 loss 降不下去，换 Adam 瞬间就好了），<strong>也可以带来一堆奇奇怪怪的问题</strong>（比如单词词频差异很大，当前 batch 没有的单词的词向量也被更新；再比如Adam和L2正则结合产生的复杂效果）。用的时候要胆大心细，万一遇到问题找各种魔改 Adam（比如 <a href="https://www.zhihu.com/question/265357659/answer/580469438">MaskedAdam</a>, AdamW 啥的）抢救。</p><p>8、subword 总是会很稳定地涨点，只管用就对了。</p><p>9、<strong>GPU 上报错时尽量放在 CPU 上重跑</strong>，错误信息更友好。例如 “ERROR:tensorflow:Model diverged with loss = NaN” 其实很有可能是输入 ID 超出了 softmax 词表的范围。</p><p><strong>10、别没耐心</strong>！<br>**有些指标是有滞后性的，需要等训练一段时间才开始动。**很多人训练几步看没什么效果就把程序停掉开始 debug 了，但其实代码毫无问题。如此反复好几天甚至一两周都在原地踏步，其实需要做的仅仅是让程序自个儿安安静静地跑上几个小时或者一天……</p><h3 id="相关trick">相关trick</h3><ul><li><p>fine-tuning: 通常来说，直接把预训练模型来用效果不一定足够好，因此需要进行fine-tuning（微调）。fine-tuning需要冻结网络的前几层参数，只更新网络结构的后面几层和最后的全连接层，这样效果会更好。</p></li><li><p>Learning rate:在迁移学习的微调过程中一般不建议使用过大的学习率，通常来说1e-5是比较合适的选择。</p></li></ul><h4 id="迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。">迁移学习往往还和你的任务中的数据关系密切，可以考虑以下几种情况。</h4><ul><li><h5 id="新的数据集较小，并且和pre-trained-model所使用的训练数据集相似度较高">新的数据集较小，并且和pre-trained model所使用的训练数据集相似度较高</h5><p>由于数据集较小，在进行finetune存在overfit的风险，又由于数据集和原始数据集相似度较高，因此二者不论是local feature还是global feature都比较相   近，所以此时最佳的方法是把CNN网络当做特征提取器然后训练一个分类器进行分类</p></li><li><h5 id="新的数据集较大，并且和pre-trained-model所使用的训练数据集相似度较高：">新的数据集较大，并且和pre-trained model所使用的训练数据集相似度较高：</h5><p>很明显，此时我们不用担心overfit，因此对全部网络结构进行fine-tune是较好的。</p></li><li><h5 id="新的数据集较小，并且和pre-trained-model所使用的训练数据集差异很大：">新的数据集较小，并且和pre-trained model所使用的训练数据集差异很大：</h5><p>由于数据集较小，不适合进行fine-tune，由于数据集差异大，应该在单独训练网络结构中较高的层，前面几层local的就不用训练了，直接固定权值。在实际中，这种问题下较好的解决方案一般是从网络的某层开始取出特征，然后训练SVM分类器。</p></li><li><h5 id="新的数据集较大，并且和pre-trained-model所使用的训练数据集差异很大：">新的数据集较大，并且和pre-trained model所使用的训练数据集差异很大：</h5><p>本来由于数据集较大，可以从头开始训练的，但是在实际中更偏向于训练整个pre-trained model的网络。</p></li></ul><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 微调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度裁剪</title>
      <link href="/2021/08/12/deep_learning/gradient-clip/"/>
      <url>/2021/08/12/deep_learning/gradient-clip/</url>
      
        <content type="html"><![CDATA[<blockquote><p>阅读代码 optimizer_config = dict(grad_clip=dict(max_norm=35, norm_type=2))，就此探究一下grap_clip。他的作用是梯度裁剪，为了防止梯度爆炸。其中max_norm是最大梯度阈值，norm_type是指定的范数类型。</p></blockquote><h2 id="梯度爆炸">梯度爆炸</h2><p>梯度爆炸就是在梯度更新的时候偏导数很大，导致更新参数无法收敛到最值（总是跳到其他不好的地方）。</p><p>$$<br>w_1=w_1− \alpha \frac{∂J(w)}{∂w1}<br>$$</p><p>$$<br>w_2=w_2− \alpha \frac{∂J(w)}{∂w2}<br>$$</p><p><img src="https://picture.mulindya.com/gradient-exp-pic1.png" alt=""></p><h2 id="梯度裁剪">梯度裁剪</h2><p>梯度裁剪是解决<strong>梯度爆炸</strong>的一种高效的方法，这里介绍梯度裁剪（Gradient Clipping）的方法，对梯度进行裁剪，论文提出对梯度的L2范数进行裁剪，也就是所有参数偏导数的平方和再开方。<br>$$<br>g_1=\frac{∂J(w)}{∂w1}<br>$$</p><p>$$<br>g_2=\frac{∂J(w)}{∂w2}<br>$$</p><p>设定裁剪阈值为 C = max_norm，$\Vert g\Vert_2= \sqrt{g<sup>2_1+g</sup>2_2}$</p><p>当$\Vert g\Vert_2$大于c时：</p><p>$$<br>g = \frac{c}{\Vert g \Vert_2} \cdot g<br>$$<br>当$\Vert g\Vert_2$小于等于C时：g不变。其中，$\frac{c}{\Vert g \Vert_2}$是一个标量</p><h2 id="总结">总结</h2><p>训练模型出现Loss值出现跳动，一直不收敛时，除了设小学习率之外，梯度裁剪也是一个好方法。</p><p>然而效果不佳时，那这就跟学习率和梯度爆炸没啥关系了。因此，<strong>学习率</strong>的设定和<strong>梯度裁剪</strong>的阈值并不能提高模型的准确率</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习，梯度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer05 替换空格</title>
      <link href="/2021/08/11/leetcode/leetcode-offer05/"/>
      <url>/2021/08/11/leetcode/leetcode-offer05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>替换空格</p></blockquote><h2 id="题目">题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成"%20"。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">输入：s = <span class="hljs-string">"We are happy."</span><br>输出：<span class="hljs-string">"We%20are%20happy."</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= s 的长度 &lt;= 10000</li></ul><h2 id="题解">题解</h2><p>直接替换即可。相当于使用replace方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">replaceSpace</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>       <span class="hljs-comment">#相当于现成函数 return s.replace(" ","%20")</span><br>        result = <span class="hljs-string">""</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> x==<span class="hljs-string">' '</span>:<br>                x = <span class="hljs-string">"%20"</span><br>            result += x<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer04 二维数组中的查找</title>
      <link href="/2021/08/11/leetcode/leetcode-offer04/"/>
      <url>/2021/08/11/leetcode/leetcode-offer04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二维数组中的查找</p></blockquote><h2 id="题目">题目</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="示例-1：">示例 1：</h3><p>现有矩阵 matrix 如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>],<br>  [<span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>],<br>  [<span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>],<br>  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span>],<br>  [<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span>]<br>]<br></code></pre></td></tr></tbody></table></figure><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><h3 id="提示：">提示：</h3><ul><li>0 &lt;= n &lt;= 1000</li><li>0 &lt;= m &lt;= 1000</li></ul><h2 id="题解">题解</h2><p>当开始想要采用二分法的思想进行判断。但是发现二分只能考虑到左上和右下块的内容。右上和左下的内容无法判断其大小划分。所以会有视觉盲区无法二分缩小区域。</p><p><font color="purple">二维数组无法用二分法，因为其“二分”是分为4份，无法充分涵盖进行判断，会出现错误。</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberIn2DArray</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(matrix): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        si,sj = <span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        ei,ej = <span class="hljs-built_in">len</span>(matrix)-<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isExit</span>(<span class="hljs-params">matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], si, sj, ei, ej, target: <span class="hljs-built_in">int</span></span>):</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (si&lt;=ei <span class="hljs-keyword">and</span> sj&lt;=ej): <span class="hljs-comment">#先判断范围</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span>(target&lt;matrix[si][sj] <span class="hljs-keyword">or</span> target&gt;matrix[ei][ej]): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span>(target==matrix[si][sj] <span class="hljs-keyword">or</span> target==matrix[ei][ej]): <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            mi,mj = <span class="hljs-built_in">int</span>((si+ei)/<span class="hljs-number">2</span>),<span class="hljs-built_in">int</span>((sj+ej)/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(target==matrix[mi][mj]):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> (target&gt;matrix[mi][mj]):<br>                <span class="hljs-keyword">return</span> isExit(matrix,mi+<span class="hljs-number">1</span>,mj,ei,ej,target) <span class="hljs-keyword">or</span> isExit(matrix,mi,mj+<span class="hljs-number">1</span>,ei,ej,target)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> isExit(matrix,si,sj,mi-<span class="hljs-number">1</span>,mj,target) <span class="hljs-keyword">or</span> isExit(matrix,si,sj,mi,mj-<span class="hljs-number">1</span>,target)<br>        <span class="hljs-keyword">return</span> isExit(matrix,si,sj,ei,ej,target)<br></code></pre></td></tr></tbody></table></figure><p>使用线性查找的方法，可以使得复杂度从暴力的O(n*m)到O(n+m)<br>思想是选取左下角或者右上角，周围不均衡的点开始进行判断，这样才知道应该向哪个方向缩小区域.</p><p><font color="hotpink">例如此处是选取左下角作为初始，向上此列逐渐变小，向右此行逐渐变大。因此target如果比此点小，就向上移动查找，如果比此点大，就向右查找。</font></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberIn2DArray</span>(<span class="hljs-params">self, matrix: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(matrix): <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        i,j = <span class="hljs-built_in">len</span>(matrix)-<span class="hljs-number">1</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j&lt;=<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span>(target==matrix[i][j]):<span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span>(target&gt;matrix[i][j]):j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:i -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 数组查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer03 数组中重复的数字</title>
      <link href="/2021/08/11/leetcode/leetcode-offer03/"/>
      <url>/2021/08/11/leetcode/leetcode-offer03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数组中重复的数字</p></blockquote><h2 id="题目">题目</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<br><span class="hljs-string">[2, 3, 1, 0, 2, 5, 3]</span><br>输出：<span class="hljs-number">2</span> 或 <span class="hljs-number">3</span> <br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>2 &lt;= n &lt;= 100000</li></ul><h2 id="题解">题解</h2><p>创建一个flag数组进行标记；</p><p>指定大小的数组创建</p><p><strong>填坑：</strong> <font color="red"> 不要使用后者,因为后者是浅拷贝，改变某一元素，该列均会改变</font></p><ul><li><p>一维</p><p>a = [0 for _ in range(n)]  《=》  a = [0] * n</p></li><li><p>二维</p><p>a = [[0 for col in range(m)] for row in range(n)]  <em># 创建一个n*m的二维矩阵a，每个初值都是0</em>   《=》  a = [[0] *m] *n</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRepeatNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        flag = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))] <span class="hljs-comment">#创建长度为nums的数组 也可以用[0]*n</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>            flag[x] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(flag[x]&gt;<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></tbody></table></figure><p><font color="purple" size="4">实际上无需构建新的数组进行标记，可以直接使用set的长度进行判断。或者使用sort，使用list的sort方法。判断相邻的元素是否相等。</font></p><p>方法1：利用python set的无序不重复特性：利用Python中的set集合为无序不重复集合，通过判断temp_set的长度确定是否是重复数字。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRepeatNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        temp_set = <span class="hljs-built_in">set</span>()<br>        repeat = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            temp_set.add(nums[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(temp_set) &lt; i + <span class="hljs-number">1</span>:<br>                repeat = nums[i]<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> repeat<br></code></pre></td></tr></tbody></table></figure><p>方法2：利用python的sort函数排序，然后计算相邻两个数据是否相等即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRepeatNumber</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i]==nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> nums[i]<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 数组 </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dvc相关设置</title>
      <link href="/2021/08/10/dvc/dvc-config/"/>
      <url>/2021/08/10/dvc/dvc-config/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote><p>运行 sh <a href="http://setup.sh">setup.sh</a> detection报错：</p><blockquote><p>(base) root@9b1a4b217508:/workspace/fanmeilin/project/task/ai_lab# sh <a href="http://setup.sh">setup.sh</a> detection<br><a href="http://setup.sh">setup.sh</a>: 12: <a href="http://setup.sh">setup.sh</a>: dvc: not found<br>cp: failed to get attributes of ‘assets/examples’: No such file or directory<br>[*] copy DETECTION skeleton scripts to upper directory</p></blockquote><p>原因是未安装dvc，运行下面的命令安装dvc</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install dvc==<span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">pip</span> install 'dvc[s<span class="hljs-number">3</span>]'<br></code></pre></td></tr></tbody></table></figure><blockquote><p>在Win平台下可能会报错：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>Cannot uninstall 'ruamel-yaml'. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.<br></code></pre></td></tr></tbody></table></figure><p>此时需要进入python 的lib/site-packages 中删除 ‘ruamel-yaml’ 相关的文件</p></blockquote><p><strong>注意：</strong> dvc 2.3.0 版本与之后的hash计算方法不同，不能混用</p><p>再次执行 sh <a href="http://setup.sh">setup.sh</a> detection报错</p><blockquote><p>ERROR: unexpected error - Cannot connect to host ceph01:80 ssl:default [Name or service not known]: [Errno -2] Name or service not known</p></blockquote><p>则修改etc/hosts文件</p><ul><li>配置hosts文件，在hosts文件中增加以下内容<br><code>192.168.10.91 ceph01</code></li></ul><h5 id="详细dvc的各种操作，可移步-师兄博客-DVC-使用手册"><em>详细dvc的各种操作，可移步</em> <a href="https://www.zywvvd.com/2020/12/17/dvc/dvc/">师兄博客 DVC 使用手册</a></h5>]]></content>
      
      
      <categories>
          
          <category> dvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的ssh相关配置</title>
      <link href="/2021/08/10/docker/docker-ssh/"/>
      <url>/2021/08/10/docker/docker-ssh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考师兄博客：<a href="https://www.zywvvd.com/2020/11/02/windows/win_ssh_linux_docker/win_ssh_linux_docker/">https://www.zywvvd.com/2020/11/02/windows/win_ssh_linux_docker/win_ssh_linux_docker/</a></p></blockquote><blockquote><p>ssh是较可靠，专为远程登录会话和其他网络服务提供安全性的协议，广泛用于远程登录的场景，也是远程调试代码的神兵利器。在开发中经常会在服务器启动自己的 docker 容器进行开发，又需要调试代码，vim的调试环境配置起来门槛又太高。于是就有了使用Windows直接ssh打通docker进行调试的需求。本文记录Windows远程登录Linux服务器docker容器的方法。</p></blockquote><h2 id="环境说明">环境说明</h2><ul><li>登录主机操作系统 Win 10</li><li>被登录主机操作系统 docker container in Linux</li><li>主机与被登录主机（此处指服务器，不是docker）网络联通，IP在同一网段</li><li>服务器与docker的IP在同一网段</li></ul><h2 id="配置方法">配置方法</h2><h3 id="建立docker与Linux服务器的端口映射">建立docker与Linux服务器的端口映射</h3><blockquote><p>ssh协议链接时默认使用22端口，Windows与docker的端口往往不能直接进行映射（很可能不在一个网段），因此需要将docker的22端口映射到Linux服务器的某个端口，此时需要在建立docker容器时进行<a href="https://www.zywvvd.com/2020/05/14/coding/environment/wingide-remote-docker/wingide-remote-docker/#docker%E9%85%8D%E7%BD%AE">配置</a>：</p></blockquote><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker run -it --name vvd -p <span class="hljs-number">3721</span>:<span class="hljs-number">22</span> -v <span class="hljs-regexp">/root/</span>tmp:<span class="hljs-regexp">/root/</span>tmp my_docker bash<br></code></pre></td></tr></tbody></table></figure><ul><li>其中 <code>-p</code> 的部分表示将本机（服务器）的3721端口映射到容器的22端口。</li></ul><h3 id="容器内部安装ssh服务">容器内部安装ssh服务</h3><blockquote><p>需要在被登录的容器内部建立并启动ssh服务。</p></blockquote><ul><li>首先需要安装：</li></ul><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-builtin-name">get</span> update<br>apt-<span class="hljs-builtin-name">get</span> install openssh-server<br>apt-<span class="hljs-builtin-name">get</span> install openssh-client<br></code></pre></td></tr></tbody></table></figure><ul><li>安装完成后需要容器每次启动时自动运行相关服务，可以在 <code>~/.bashrc</code>中加入：</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/ssh start<br></code></pre></td></tr></tbody></table></figure><blockquote><p>这样就保证了docker容器自动启动该服务。</p></blockquote><ul><li>查看ssh运行状态</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/ssh status<br></code></pre></td></tr></tbody></table></figure><blockquote><p>如果是 <code>* sshd is running</code> 说明ssh正常运行</p></blockquote><h3 id="修改容器内root用户登录设置">修改容器内root用户登录设置</h3><blockquote><p>有的容器默认不支持root用户远程使用ssh协议进行密码登录的，此时需要更改设置。</p></blockquote><ul><li>打开 <code>/etc/ssh/sshd_config</code>文件：</li></ul><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># PermitRootLogin prohibit-password # 默认打开 禁止root用户使用密码登陆，需要将其注释</span><br><span class="hljs-attribute">RSAAuthentication</span> <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用 RSA 认证</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用公钥私钥配对认证方式</span><br>PermitRootLogin <span class="hljs-literal">yes</span> <span class="hljs-comment">#允许root用户使用ssh登录</span><br></code></pre></td></tr></tbody></table></figure><ul><li>将 <code>PermitRootLogin</code> 设置为 yes</li></ul><h3 id="修改root密码">修改root密码</h3><blockquote><p>远程登录时需要使用系统的用户密码，我们就直接使用root用户登录好了，需要设置新建容器的密码：</p></blockquote><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd root</span><br></code></pre></td></tr></tbody></table></figure><h3 id="设置SSH">设置SSH</h3><ul><li><a href="https://www.zywvvd.com/2020/02/23/git/link_github/Git-connect-remote-pos/#%E5%88%9B%E5%BB%BASSH%E5%AF%86%E9%92%A5">本地生成ssh key</a></li><li>将.pub 内容复制粘贴加入到远程 ~/.ssh/authorized_keys</li></ul><h3 id="SSH连接服务器">SSH连接服务器</h3><blockquote><p>需要用户名（被登录端用户）与被登录的主机ip和端口号</p><p>例如： 用户名- root ip：192.168.10.12 端口映射为 3721</p></blockquote><ul><li>linux</li></ul><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> root@<span class="hljs-number">192.168.10.12:3721</span><br></code></pre></td></tr></tbody></table></figure><ul><li>Windows</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span> -p <span class="hljs-number">3721</span> root@<span class="hljs-number">192.168.10.12</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200256.png" alt=""></p><ul><li>如果不清楚Linux系统端口映射配置情况：</li></ul><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">iptables -<span class="hljs-built_in">t</span> nat -L -<span class="hljs-built_in">n</span><br></code></pre></td></tr></tbody></table></figure><h3 id="X-shell配置">X-shell配置</h3><blockquote><p>命令行ssh登录成功后就可以在X-shell中建立配置信息方便地连接了。</p></blockquote><ul><li>新建会话，填写名称、IP、端口号（我们刚刚配置过的）：</li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200522.png" alt=""></p><ul><li>用户身份认证，填入用户名密码（刚刚配置过的）：</li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200640.png" alt=""></p><ul><li>随后就可以使用该会话直接登录docker容器了，为远程调试打下了坚实的基础：</li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201102200804.png" alt=""></p><h3 id="填坑">填坑</h3><ul><li><p>ssh: Could not resolve hostname 192.168.10.12:3721: Name or service not known</p><blockquote><p>这是在Windows中使用了Linux格式的SSH登录命令导致的解析错误</p><p>将命令语法更换为Windows的格式即可</p></blockquote></li><li><p>root 用户无论如何密码不被接受</p><blockquote><p>需要在被登录主机 /etc/ssh/sshd_config 中设置：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># PermitRootLogin prohibit-password # 默认打开 禁止root用户使用密码登陆，需要将其注释</span><br><span class="hljs-attribute">RSAAuthentication</span> <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用 RSA 认证</span><br>PubkeyAuthentication <span class="hljs-literal">yes</span> <span class="hljs-comment">#启用公钥私钥配对认证方式</span><br>PermitRootLogin <span class="hljs-literal">yes</span> <span class="hljs-comment">#允许root用户使用ssh登录</span><br></code></pre></td></tr></tbody></table></figure><ul><li>重点：<strong>PermitRootLogin yes</strong></li></ul></blockquote></li><li><p>Connection to 192.168.10.12 closed.</p></li><li><p>或</p></li><li><p>Connection closed by foreign host.</p><blockquote><p>意思是 断开主机链接了，出现这种问题，跟你的IPTABLES，防火墙什么的都没关系。</p><p>造成这个原 因是因为原来连接到SSHD服务器进程的22端口，当你的客户端突然断开时，服务器端的TCP连接就处于一个半打开状态。当下一次同一客户机再次建立 TCP连接时，服务器检测到这个半打开的TCP连接，并向客户机回传一个置位RST的TCP报文，客户机就会显示connection closed by foreign host。<br>这是TCP协议本身的一个保护措施，并不是什么错误，你只要再重新连接服务器就能连上。</p><p>——— <a href="http://www.pooy.net/connection-closed-foreign-host.html">http://www.pooy.net/connection-closed-foreign-host.html</a></p><p>总结一下解决方案： <strong>关机重启</strong></p></blockquote></li></ul><h3 id="关于ssh的相关配置">关于ssh的相关配置</h3><h4 id="修改配置文件">修改配置文件</h4><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>ssh<br>vi ssh_config <span class="hljs-comment">#可设置ssh的默认端口（22）</span><br>vi sshd_config<br></code></pre></td></tr></tbody></table></figure><p>ssh_config和sshd_config都是ssh服务器的配置文件，二者区别在于，前者是针对客户端的配置文件，后者则是针对服务端的配置文件。两个配置文件都允许你通过设置不同的选项来改变客户端程序的运行方式。</p><h4 id="重启ssh服务">重启ssh服务</h4><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service sshd restart</span><br></code></pre></td></tr></tbody></table></figure><p>如果报错 sshd: unrecognized service 则需要开启ssh服务。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/i</span>nit.d/ssh start<br></code></pre></td></tr></tbody></table></figure><h2 id="vscode连接远程服务器">vscode连接远程服务器</h2><ul><li><p>正确的ssh服务</p></li><li><p>密码设置完成（passwd root）</p></li></ul><h3 id="安装插件">安装插件</h3><ul><li><p>安装 Remote Development 插件</p><blockquote><p>会自动安装 Remote-WSL / Containers / SSH 等插件。</p></blockquote></li></ul><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028143530.png" alt=""></p><h3 id="配置主机信息">配置主机信息</h3><blockquote><p>ctrl + shift + p</p></blockquote><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028174129.png" alt=""></p><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028175152.png" alt=""></p><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host Enter<br>  HostName <span class="hljs-number">192.168</span>.<span class="hljs-number">10.15</span><br>  Port <span class="hljs-number">12345</span><br>  <span class="hljs-keyword">User</span> <span class="hljs-title">root</span><br>  IdentityFile ~\.ssh\id_rsa<br>  IdentitiesOnly yes<br></code></pre></td></tr></tbody></table></figure><h3 id="vs-code-连接远程主机">vs code 连接远程主机</h3><p><img src="https://photos.zywvvd.com/images_matrixtime/20201028175324.png" alt=""></p><blockquote><p>之后选择目标主机的操作系统。</p></blockquote><ul><li><p>成功连接到远程主机：</p></li><li><p>打开文件夹运行程序时，选择使用的Python环境：</p></li></ul><h4 id="相对路径的设置">相对路径的设置</h4><p>在读取文件时，可能使用相对路径出现错误。</p><blockquote><p>python 插件设置中没有设置<code>终端执行命令时使用文件的路径代替现在打开的目录</code>。</p></blockquote><h3 id="解决方案">解决方案</h3><ul><li>搜索配置 <code>execute in file</code>：</li></ul><p><img src="https://photos.zywvvd.com/win11-mt/20210717114300.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 远程配置 </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker相关命令</title>
      <link href="/2021/08/10/docker/docker-intro/"/>
      <url>/2021/08/10/docker/docker-intro/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简要介绍Docker，记录Docker常用命令使用方法。</p><p>搬运自师兄的博客 又见苍岚 ：<a href="https://www.zywvvd.com/2020/05/06/docker/docker_usage/">https://www.zywvvd.com/2020/05/06/docker/docker_usage/</a></p></blockquote><h3 id="Docker-简介">Docker 简介</h3><blockquote><p>**Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。**Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p></blockquote><h3 id="Docker-使用流程">Docker 使用流程</h3><ul><li><a href="https://docs.docker.com/desktop/">安装docker</a></li><li>创建Image</li><li>从Image创建Container</li><li>在Container中工作</li><li>将在Container中做的修改提交给Image</li><li>销毁Container</li></ul><h3 id="命令介绍">命令介绍</h3><ul><li>拉取 image</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> image pull<span class="hljs-meta"> [docker-url]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>获取docker images 列表</li></ul><figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker images<br>或<br>docker <span class="hljs-keyword">image</span> <span class="hljs-keyword">ls</span><br></code></pre></td></tr></tbody></table></figure><ul><li>建立container （nvidia docker)</li></ul><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">NV_GPU=<span class="hljs-selector-attr">[gpu_num]</span> nvidia-docker run -it --name <span class="hljs-selector-attr">[container_name]</span> --shm-size=<span class="hljs-selector-attr">[shm_size]</span> --rm -v <span class="hljs-selector-attr">[current_dir]</span>:<span class="hljs-selector-attr">[container_dir]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[current_port]</span>:<span class="hljs-selector-attr">[container_port]</span> <span class="hljs-selector-attr">[image_name]</span>:<span class="hljs-selector-attr">[image_tag]</span>  <span class="hljs-selector-attr">[command]</span> <br></code></pre></td></tr></tbody></table></figure><p>实例：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvidia</span>-docker run -it --name mlfan --shm-size=<span class="hljs-number">10</span>g -v /disk/fanmeilin:/workspace/fanmeilin -p <span class="hljs-number">12345</span>:<span class="hljs-number">22</span> -p <span class="hljs-number">12346</span>:<span class="hljs-number">8080</span> -p <span class="hljs-number">12347</span>:<span class="hljs-number">5678</span> tf-<span class="hljs-number">1</span>.<span class="hljs-number">14</span>-<span class="hljs-number">2</span>.<span class="hljs-number">0</span>-<span class="hljs-number">2</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> bash<br></code></pre></td></tr></tbody></table></figure><p><font color="SlateBlue" size="4">注意不要加 --rm&nbsp; 否则载在container stop之后会自动删除此容器</font></p><blockquote><p>NV_GPU: container中可见的GPU，如果不设置可见所有GPU</p><p>-it: 将容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器</p><p>–name: 容器名称，如果不设置会随机分配一个名字</p><p>–shm-size: 容器共享内存大小设置。如果不设置默认大小64M，对于需要使用共享内存的情况往往是不够用的，如果设置为10g，这样配置： <code>--ssh-size="10g"</code></p><p>–rm: 容器关闭后自动删除，如果不设置容器不会自动删除</p><p>-v: 驱动器映射，将本机的目录映射到容器的指定文件夹中；需要说明的是，在主机文件夹中的挂载目录在容器中是可见的；需要再说明的是容器启动时主机挂载的目录容器是见不到的；最后说明，容器关闭再打开就可以看到主机挂载的所有文件夹了。</p><p>-p: 暴漏容器的端口到本机的端口上，例如用于ssh连接容器时需要将容器的22端口暴露到主机的端口上(比如3721)，则可以设置 <code>-p 3721:22</code></p><p>image_name, image_tag: 这是docker镜像的名称与标记，如果使用本机镜像可以在docker images列表中查询到</p><p>command: 启动容器后内部执行的第一个命令，一般为 <code>/bin/bash</code></p></blockquote><ul><li>查询container列表</li></ul><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker container <span class="hljs-keyword">ls</span> <span class="hljs-params">--all</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>–all: 加上该参数会显示没有在运行的容器，不加的话仅显示运行中的容器</p></blockquote><ul><li>停止指定的容器运行</li></ul><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> kill <span class="hljs-comment">[containerID]</span><br>docker stop <span class="hljs-comment">[containerID]</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。<code>docker container stop</code>命令相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p></blockquote><ul><li>启动停止的容器</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> start<span class="hljs-meta"> [containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>重启运行的容器</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart<span class="hljs-meta"> [containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>删除指定的容器文件（仅在停止运行时可用）</li></ul><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> rm <span class="hljs-comment">[containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>查看容器输出</li></ul><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker <span class="hljs-keyword">container</span> logs <span class="hljs-comment">[containerID]</span><br></code></pre></td></tr></tbody></table></figure><ul><li>启动容器的一个终端</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it [containerID] <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></tbody></table></figure><blockquote><p>此种方法启动的终端，即使退出也不会关闭容器</p><p>相反 - 如果直接通过端口映射连接 docker 建立的ssh链接，窗口退出后该终端的工作也会一同停止</p></blockquote><ul><li>进入容器的主终端</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> attach<span class="hljs-meta"> [containerID]</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>连接到容器的主终端，该终端退出后容器关闭。</p><p>如果不希望退出后关闭，可以加入选项 <code>--sig-proxy=false</code></p></blockquote><ul><li>退出终端</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ctrl <span class="hljs-selector-tag">p</span> + ctrl <span class="hljs-selector-tag">q</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>可以在退出终端的同时保持终端继续工作</p></blockquote><ul><li>退出容器</li></ul><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>在容器中运行此命令</p></blockquote><ul><li>拷贝容器里的文件到本机</li></ul><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker container cp [containerID]:[<span class="hljs-regexp">/path/</span>to/<span class="hljs-keyword">file</span>]<br></code></pre></td></tr></tbody></table></figure><ul><li>提交容器修改到镜像</li></ul><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker commit -<span class="hljs-selector-tag">a</span> <span class="hljs-selector-attr">[name]</span> -m <span class="hljs-selector-attr">[comments]</span> -<span class="hljs-selector-tag">p</span>  <span class="hljs-selector-attr">[containerID[:TAG]</span>]<br></code></pre></td></tr></tbody></table></figure><blockquote><p>-a: 提交的镜像作者</p><p>-m: 提交时的说明文字</p><p>-p: 在commit时，将容器暂停</p></blockquote><ul><li>删除镜像</li></ul><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [image]</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>或</p></blockquote><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image rm [image]<br></code></pre></td></tr></tbody></table></figure><blockquote><p>支持的子命令如下：</p></blockquote><ul><li><code>-f, -force</code>: 强制删除镜像，即便有容器引用该镜像；</li><li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li></ul><h3 id="参考资料">参考资料</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 远程配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer10-2 青蛙跳台阶问题</title>
      <link href="/2021/08/10/leetcode/leetcode-offer10-2/"/>
      <url>/2021/08/10/leetcode/leetcode-offer10-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>青蛙跳台阶问题</p></blockquote><h2 id="题目">题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">21</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例3：">示例3：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= n &lt;= 100</li></ul><h2 id="题解">题解</h2><p>实际上是斐波那契数列的变种。跳上n级台阶的方法个数 可以分解为：<em>跳上此台阶前的一步是1步还是2步</em>。也就是 $f(n) = f(n-1) + f(n-2)$。</p><p>不同之处在于此时的f(0) = 1</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numWays</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        a,b = <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            a,b = b,a+b<br>        <span class="hljs-keyword">return</span> a%<span class="hljs-number">1000000007</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> idea </tag>
            
            <tag> 斐波那契 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer10-1 斐波那契数列</title>
      <link href="/2021/08/10/leetcode/leetcode-offer10-1/"/>
      <url>/2021/08/10/leetcode/leetcode-offer10-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>斐波那契数列</p></blockquote><h2 id="题目">题目</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>$$<br>F(0) = 0,   F(1) = 1 \\<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>$$<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>0 &lt;= n &lt;= 100</li></ul><h2 id="题解">题解</h2><p>有三种方向：</p><ul><li><p>使用递归</p><p>大量重复计算，时间超时。</p></li><li><p>使用数组存储</p><p>新建长度为n的数组，在递归基础上，存储计算的结果，后直接取用。但是占用了额外的空间$O(n)$</p></li><li><p>使用动态规划</p><p><code>以其公式F(N) = F(N - 1) + F(N - 2)为转移方程。</code></p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        a,b = <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            a,b = b,a+b <span class="hljs-comment">#sum = a+b a = b b = sum a相当于f(i) b相当于f(i+1)</span><br>        <span class="hljs-keyword">return</span> a%<span class="hljs-number">1000000007</span><br>    <span class="hljs-comment"># def fib(self, n: int) -&gt; int:</span><br>    <span class="hljs-comment">#     if(n==0): return 0</span><br>    <span class="hljs-comment">#     if(n==1): return 1</span><br>    <span class="hljs-comment">#     return (self.fib(n-1)+self.fib(n-2))%1000000007 #超时 递归时间复杂度大</span><br></code></pre></td></tr></tbody></table></figure><p>循环n次</p><p>注意<code>a,b = b,a+b</code> 相当于sum = a+b ；a = b； b = sum ；</p><p>第i轮中 a相当于f(i)，b相当于f(i+1) 。因此最后返回a</p>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 斐波那契 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer09 用两个栈实现队列</title>
      <link href="/2021/08/10/leetcode/leetcode-offer09/"/>
      <url>/2021/08/10/leetcode/leetcode-offer09/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用两个栈实现队列</p></blockquote><h2 id="题目">题目</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><h3 id="示例-1：">示例 1：</h3><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">"CQueue"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"deleteHead"</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="示例-2：">示例 2：</h3><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">"CQueue"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"deleteHead"</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></tbody></table></figure><h3 id="提示：">提示：</h3><ul><li>1 &lt;= values &lt;= 10000</li><li>最多会对 appendTail、deleteHead 进行 10000 次调用</li></ul><h2 id="题解">题解</h2><p>使用两个栈，<em>一个作为插入栈，一个作为删除栈</em>。<code>使用list进行相关操作（append，pop）</code>；在插入时直接对stack1进行append操作，删除时首先需要构建删除栈内容，再进行判断，最后同步到插入栈中（此时删除栈又为空）。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># stack1是insert栈 stack2是delete栈</span><br>        self.stack1 = [] <span class="hljs-comment">#list作用和stack类似</span><br>        self.stack2 = []<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">appendTail</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self.stack1.append(value) <span class="hljs-comment"># 直接插入栈顶</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteHead</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">while</span> self.stack1: <span class="hljs-comment">#首先更新delete栈</span><br>            self.stack2.append(self.stack1.pop())<br>        <span class="hljs-comment">#进行deleteHead操作</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.stack2: <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        popitem = self.stack2.pop()<br>        <span class="hljs-comment"># 将更新结果写回stack1中 保持一致</span><br>        <span class="hljs-keyword">while</span> self.stack2:<br>            self.stack1.append(self.stack2.pop())<br>        <span class="hljs-keyword">return</span> popitem<br><br><span class="hljs-comment"># Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = CQueue()</span><br><span class="hljs-comment"># obj.appendTail(value)</span><br><span class="hljs-comment"># param_2 = obj.deleteHead()</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mahalanobis_distance</title>
      <link href="/2021/08/09/math/Mahalanobis-distance/"/>
      <url>/2021/08/09/math/Mahalanobis-distance/</url>
      
        <content type="html"><![CDATA[<blockquote><p>马氏距离(Mahalanobis Distance)是度量学习中一种常用的距离指标，同欧氏距离、曼哈顿距离、汉明距离等一样被用作评定数据之间的相似度指标。但却可以应对高维线性分布的数据中各维度间非独立同分布的问题。</p></blockquote><p><em>使用马氏距离，对高维非独立分布的数据进行距离度量。</em></p><p><strong>那我们为什么要用马氏距离呢？</strong><br>马氏距离有很多<strong>优点：</strong> <strong>马氏距离不受量纲的影响</strong>，两点之间的马氏距离与原始数据的测量单位无关；由标准化数据和中心化数据(即原始数据与均值之差）计算出的二点之间的马氏距离相同。<strong>马氏距离还可以排除变量之间的相关性的干扰</strong>。</p><h2 id="什么是马氏距离">什么是马氏距离</h2><p>马氏距离(Mahalanobis Distance)是一种距离的度量，可以看作是欧氏距离的一种修正，修正了欧式距离中各个维度尺度不一致且相关的问题。</p><p>单个数据点的马氏距离</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic1.png" alt=""></p><p>数据点x, y之间的马氏距离</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic2.png" alt=""></p><p><em>其中Σ是多维随机变量的协方差矩阵，μ为样本均值，如果协方差矩阵是单位向量，也就是各维度独立同分布，马氏距离就变成了欧氏距离。</em></p><h2 id="马氏距离实际意义">马氏距离实际意义</h2><p>那么马氏距离就能能干什么？它比欧氏距离好在哪里？举几个栗子</p><p><strong>欧式距离近就一定相似？</strong></p><p>先举个比较常用的例子，身高和体重，这两个变量拥有不同的单位标准，也就是有不同的scale。比如身高用毫米计算，而体重用千克计算，显然差10mm的身高与差10kg的体重是完全不同的。但在普通的欧氏距离中，这将会算作相同的差距。</p><p><strong>归一化后欧氏距离近就一定相似？</strong></p><p>当然我们可以先做归一化来消除这种维度间scale不同的问题，但是样本分布也会影响分类</p><p>举个一维的栗子，现在有两个类别，统一单位，第一个类别均值为0，方差为0.1，第二个类别均值为5，方差为5。那么一个值为2的点属于第一类的概率大还是第二类的概率大？距离上说应该是第一类，但是直觉上显然是第二类，因为第一类不太可能到达2这个位置。</p><p>所以，在一个方差较小的维度下很小的差别就有可能成为离群点。就像下图一样，A与B相对于原点的距离是相同的。但是由于样本总体沿着横轴分布，所以B点更有可能是这个样本中的点，而A则更有可能是离群点。</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic3.png" alt=""></p><p><strong>算上维度的方差就够了？</strong></p><p>还有一个问题——如果维度间不独立同分布，样本点一定与欧氏距离近的样本点同类的概率更大吗？</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic4.png" alt=""></p><p>可以看到样本基本服从f(x) = x的线性分布，A与B相对于原点的距离依旧相等，显然A更像是一个离群点</p><p>即使数据已经经过了标准化，也不会改变AB与原点间距离大小的相互关系。所以要本质上解决这个问题，就要针对<a href="https://link.zhihu.com/?target=https%3A//www.ph0en1x.space/2018/03/06/PCA/">主成分分析</a>中的<code>主成分</code>来进行标准化。</p><h2 id="马氏距离的几何意义">马氏距离的几何意义</h2><p>上面搞懂了，马氏距离就好理解了，<u>只需要将变量<code>按照主成分进行旋转</code>，让维度间相互<strong>独立</strong>，然后进行<code>标准化</code></u>，让维度<strong>同分布</strong>就可以了。</p><p>由主成分分析可知，由于主成分就是特征向量方向，每个方向的方差就是对应的特征值，所以只需要按照特征向量的方向旋转，然后缩放特征值倍就可以了，可以得到以下的结果：</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic5.png" alt=""></p><p>离群点就被成功分离，这时候的欧式距离就是马氏距离。</p><h2 id="马氏距离的推导">马氏距离的推导</h2><p>首先要对数据点进行<em>旋转</em>，旋转至主成分，维度间线性无关，假设新的坐标为</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic6.png" alt=""></p><p>又变换后<em>维度间线性无关且每个维度自己的方差为特征值</em>，所以满足：</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic7.png" alt=""></p><p>马氏距离是旋转变换缩放之后的欧式距离，所以马氏距离的计算公式为：</p><p><img src="https://picture.mulindya.com/Mahalanobis-distance-pic8.png" alt=""></p><p>这就是之前提到的马氏距离的公式</p><h2 id="马氏距离的问题">马氏距离的问题</h2><ul><li>协方差矩阵必须满秩</li></ul><p>里面有求逆矩阵的过程，不满秩不行，要求数据要有原维度个特征值，如果没有可以考虑先进行PCA，这种情况下PCA不会损失信息</p><ul><li>不能处理非线性流形(manifold)上的问题</li></ul><p>只对线性空间有效，如果要处理流形，只能在局部定义，可以用来建立KNN图</p><blockquote><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/46626607">https://zhuanlan.zhihu.com/p/46626607</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马氏距离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eckark_young定理</title>
      <link href="/2021/08/09/math/Eckark-young/"/>
      <url>/2021/08/09/math/Eckark-young/</url>
      
        <content type="html"><![CDATA[<p>最佳低秩逼近和奇异值的关系(<em>Eckart</em>-<em>Young定理</em>)</p><h3 id="定理">定理</h3><p>Suppose a matrix $A\in \mathbb{R}^{m\times n}$has an SVD-decomposition$A=U\Sigma V^T$. Let $k &lt; r= \mathsf{rank}(A)$and truncated matrix<br>$$<br>A_k = \sum_{i=1}^k \sigma_i \mathbf u_i \mathbf v_i^T,<br>$$<br>then, for any matrix B of rank k , the minimal error is achieved with $A_k$:</p>$$\min_{\mathsf{rank}(B)=k}||A-B||_2 = || A - A_k||_2 = \sigma_{k+1}.$$<p>The same holds for Frobenius norm as well</p>$$\min_{\mathsf{rank}(B)=k}||A-B||_F = || A - A_k||_F = \sqrt{\sigma_{k+1}^2 + \cdots + \sigma_p^2}.$$<h3 id="证明-2-norm-case">证明 (2-norm case)</h3><p>Since $U^\ A_k V = \mathrm{diag}(\sigma_1,\ldots, \sigma_k,0,\ldots,0)$ it means that $A_k$ is rank K. Moreover, $U^T (A-A_k) V =  \mathrm{diag}(0,\ldots, 0,\sigma_{k+1},\ldots, \sigma_p)$with the largest singular value is $\sigma_{k+1}$ and thus $||A-A_k||_2 = \sigma_{k+1}$.</p><h3 id="证明-Frobenius-norm-case">证明 (Frobenius norm case)</h3><blockquote><p>Lemma: If $A,B \in \mathbb{R}^{m\times n}$ , with B having rank K , then $\sigma_{k+i}(A) \le \sigma_i(A-B) \text{ for all }; i.$</p></blockquote><p>To prove the lemma, first consider the case i=1, we have proved that $\sigma_{k+1}(A) \le \sigma_1(A-B) = ||A-B||_2$in the 2-norm case. Then we do the general case:</p>$$\begin{aligned} \sigma_i(A-B) = &amp; \sigma_i(A-B) + \sigma_1(B-B_k)\qquad\text{since } B=B_k\\ =&amp; \sigma_1(A-B - (A-B)_{i-1}) + \sigma_1(B-B_k)\qquad\\ \ge &amp; \sigma_1(A-B - (A-B)_{i-1}+B-B_k)   \\ =&amp; \sigma_1(A  - (A-B)_{i-1} -B_k)\\ \ge &amp; \sigma_1(A - A_{k+i-1})\\ =&amp; \sigma_{k+i}(A)   \end{aligned} $$<blockquote><p><a href="https://zhuanlan.zhihu.com/p/361938622">https://zhuanlan.zhihu.com/p/361938622</a></p><p><a href="https://zhuanlan.zhihu.com/p/75283604">https://zhuanlan.zhihu.com/p/75283604</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低秩逼近的思考</title>
      <link href="/2021/08/06/math/low-rank-app/"/>
      <url>/2021/08/06/math/low-rank-app/</url>
      
        <content type="html"><![CDATA[<blockquote><p>阅读文章<strong>Semi-orthogonal Embedding for Effificient Unsupervised Anomaly Segmentation</strong>时出现一个概念–<strong>Low-rank approximation</strong> ，就此进行相关讨论。</p></blockquote><h3 id="低秩（Low-Rank）">低秩（Low-Rank）</h3><p>如果X是一个m行n列的数值矩阵，rank(X)是X的秩，假如rank (X)远小于m和n，则我们称X是低秩矩阵。低秩矩阵每行或每列都可以用其他的行或列线性表出，可见它包含大量的冗余信息。利用这种冗余信息，可以对缺失数据进行恢复，也可以对数据进行特征提取。</p><p>图像处理中，<em>rank可以理解为图像所包含的信息的丰富程度</em>，在显示生活中，一张图片中大部分成分是相似的。比如给一张大草原的图片</p><p><img src="https://picture.mulindya.com/low-rank-app-pic1.png" alt=""></p><p>草原是由很多草组成的，而草是相似的，所以如果全是草，那么这张图所包含的信息量是很少的的，因为可以理解为草是草的复制品。而上图的蒙古包，人，马之类的则可以理解为图片所包含的信息，实际上，相对于只有草的草原图片和有草和蒙古包的草原图片，后者的秩是较高的。也就是说，图片中比较突兀的成分，比如蒙古包，比如人像照片中的红眼亮点，会增加图像矩阵的秩。而现实生活中一张不错的图片的秩其实是比较低的，如果图像的秩比较高，往往是因为图像中的噪声比较严重。比如拍照的时候ISO感光度设置过高造成噪点太过泛滥之类的。所以，<em>图像处理的低秩性其实可以拿来去除照片中的噪点</em>。</p><h3 id="低秩和稀疏">低秩和稀疏</h3><p>我们认为图像有一些公共的模式，所有图像都由这些基本的模式组成。例如，如果图像是一个叉，可以看成是一个正斜线和反斜线的叠加。<strong>只要我们找到了所有的基底（称作字典</strong>，就是上面说的正斜线和反斜线之类的东西）**，就能通过基底的线性组合表示出所有的图像。**这就好像学画画，先学会基本的画正方体、球体、圆柱体等等，就可以组合出各种各样的复杂形状。</p><p><strong>在很多情形下，基底的数量是很少的</strong>，比如一张照片拍的是一面砖墙，那么它显然具有周期重复的特点，换句话说低秩。即使整个图不低秩，往往也能找出一些相似的块，这些块是低秩的。再退一步，就算这也做不到，往往也可以把已有的数据看成一组低维的结果加上噪声，也即原来的数据<strong>可以被低秩矩阵很好的逼近</strong>。<strong>稀疏性</strong>的意思是（以稀疏表示为例），任给一个图像，<strong>字典可能是过完备的</strong>，从而用字典里的基向量表出这幅图有很多种不同的方案。我们希望<strong>选取使用基底数量最少的那种方案</strong>，</p><p>应用：</p><p><em><strong>1）矩阵填充(Matrix Completion)</strong></em></p><p><em><strong>2）鲁棒PCA</strong></em></p><p><em><strong>3）背景建模</strong></em></p><p><em><strong>4）变换不变低秩纹理（TILT）</strong></em></p><blockquote><p>在论文 <strong>Semi-orthogonal Embedding for Effificient Unsupervised Anomaly Segmentation</strong>中有一段可以参考。</p></blockquote><p><strong>Low-rank approximation of precision matrix</strong></p><p>The feature data <strong>X</strong> is subject to low-rank approximation due to the narrower target domain for anomaly-free images than the ImageNet dataset’s. The multi-scale features from different layers may also contribute to it due to the inter-dependency among the features from the layers. Inspired by the truncated SVD of a precision matrix, a low-rank embedding of input features with $W \in R^{F \times k}$,where <em>F &gt; k</em>, is considered as follows:<br>$$<br>d^2_{i,j} = X<sup>TW(W</sup>TC_{i,j}W)<sup>{−1}W</sup>TX<br>$$<br>where the below Theorem 1 shows the optimal <strong>W</strong>* is the eigenvectors related to the <em>k</em>-smallest eigenvalues of $C_{i,j}$ . Notice that 1) the computational complexity of the equation is cubically reduced to <em>O</em>($HWk^3$) set aside the cost of SVD, although which is the concern, 2) PCA embedding would fail to minimize approximation error since it uses the <em>k</em>-largest eigenvectors [14], and 3) near-zero eigenvalues may induce substantial anomaly scores.</p><p>选取协方差矩阵的k个最小的特征值对应的特征向量，进行低秩逼近</p><blockquote><p>参考</p><p><a href="https://www.zhihu.com/question/28630628">https://www.zhihu.com/question/28630628</a></p><p><a href="https://blog.csdn.net/zouxy09/article/details/24972869">https://blog.csdn.net/zouxy09/article/details/24972869</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子模块为空的解决方案</title>
      <link href="/2021/08/06/git_config/git-submodule/"/>
      <url>/2021/08/06/git_config/git-submodule/</url>
      
        <content type="html"><![CDATA[<blockquote><p>针对子模块文件夹为空的情况，采取下列解决方案。</p><p>当一个 git 项目包含子模块（submodule) 时，直接克隆下来的子模块目录里面是空的。</p></blockquote><p><strong>有两种方法解决</strong>：</p><h3 id="方法一">方法一</h3><p>如果项目已经克隆到了本地，执行下面的步骤：</p><ol><li><p>初始化本地子模块配置文件</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git submodule <span class="hljs-keyword">init</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>更新项目，抓取子模块内容。</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git submodule update</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>进入对应子模块目录，执行</p><figure class="highlight brainfuck"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">submodule</span> <span class="hljs-comment">update</span> --<span class="hljs-comment">init</span> --<span class="hljs-comment">recursive</span><br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="方法二">方法二</h3><p>另外一种更简单的方法，就是在执行 <code>git clone</code> 时加上 <code>--recursive</code> 参数。它会自动初始化并更新每一个子模块。例如：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone --recursive https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/example/</span>example.git<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo中公式显示</title>
      <link href="/2021/08/05/hexo_config/hexo-math-config/"/>
      <url>/2021/08/05/hexo_config/hexo-math-config/</url>
      
        <content type="html"><![CDATA[<blockquote><p>公式的显示问题。Hexo中Mathjax是用于显示公式的插件，但是多行显示会出现问题，有时还会出现乱码的情况。</p></blockquote><h3 id="配置">配置</h3><p>在根目录下的config_fluid.yml​文件中打开math的相关配置。</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br><span class="hljs-comment"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># Options: mathjax | katex</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="出现的问题">出现的问题</h3><h4 id="问题1">问题1</h4><ul><li>由于hexo解码时关注，%% 等连续字符，会将这部分代码解读为其他带有特殊含义的内容</li><li>如果公式中恰巧出现了此类字符，会报出上述错误</li></ul><h4 id="问题2">问题2</h4><ul><li>由于hexo在公式中的<code>\\</code>错会成了转义符，也就是说他只看见了一个反斜杠，不会执行换行命令，导致公式堆成一行</li></ul><h3 id="解决方案">解决方案</h3><h4 id="临时方案">临时方案</h4><h5 id="针对问题1">针对问题1</h5><ul><li>可以在连续的 <code>{</code> <code>}</code> <code>%</code>中间插入空格，分开就没事了</li></ul><h5 id="针对问题2">针对问题2</h5><ul><li>可以将<code>\\</code>换成<code>\\\\</code>，可以实现公式的多行正确显示</li></ul><h4 id="终极方案">终极方案</h4><ul><li><p>在官方文档中提到了可以为hexo提供标记，阻止其按照自己的规则解释我们的字符串，显示其原本的含义</p></li><li><p>标记为</p><figure class="highlight django"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">{% <span class="hljs-name">raw</span> %}</span><span class="xml"></span><br><span class="xml">$$</span><br><span class="xml">...</span><br><span class="xml">$$</span><br><span class="xml"></span><span class="hljs-template-tag">{% <span class="hljs-name">endraw</span> %}</span><br></code></pre></td></tr></tbody></table></figure></li></ul><h3 id="多行显示和对齐">多行显示和对齐</h3><ul><li><p>默认是显示为一行要实现公式多行和对齐可以使用{aligned}模式，使用"&amp;“来标记对齐位置。”\\"表示换行</p>  <figure class="highlight taggerscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">$$<br><span class="hljs-symbol">\b</span>egin{aligned}<br><span class="hljs-symbol">\b</span>oldsymbol{x}^{<span class="hljs-symbol">\m</span>athrm{T}}C<span class="hljs-symbol">\b</span>oldsymbol{x}&amp;=<span class="hljs-symbol">\b</span>oldsymbol{x}^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft[<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\r</span>ight]<span class="hljs-symbol">\b</span>oldsymbol{x} <br><span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft[<span class="hljs-symbol">\b</span>oldsymbol{x}^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight] <span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft[<span class="hljs-symbol">\l</span>eft(<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\l</span>eft(<span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight)<span class="hljs-symbol">\r</span>ight] <br><span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\m</span>athrm{E}<span class="hljs-symbol">\l</span>eft(<span class="hljs-symbol">\l</span>eft<span class="hljs-symbol">\V</span>ert <span class="hljs-symbol">\l</span>eft(X-<span class="hljs-symbol">\m</span>u<span class="hljs-symbol">\r</span>ight)^{<span class="hljs-symbol">\m</span>athrm{T}}<span class="hljs-symbol">\b</span>oldsymbol{x}<span class="hljs-symbol">\r</span>ight<span class="hljs-symbol">\V</span>ert ^{2}<span class="hljs-symbol">\r</span>ight) <br><span class="hljs-symbol">\\</span>&amp;=<span class="hljs-symbol">\s</span>igma_{X}^{2}<br><span class="hljs-symbol">\e</span>nd{aligned}<br>$$<br></code></pre></td></tr></tbody></table></figure></li><li><p>显示为</p></li></ul>$$\begin{aligned}\boldsymbol{x}^{\mathrm{T}}C\boldsymbol{x}&amp;=\boldsymbol{x}^{\mathrm{T}}\mathrm{E}\left[\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\right]\boldsymbol{x} \\&amp;=\mathrm{E}\left[\boldsymbol{x}^{\mathrm{T}}\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right] \\&amp;=\mathrm{E}\left[\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)^{\mathrm{T}}\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)\right] \\&amp;=\mathrm{E}\left(\left\Vert \left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right\Vert ^{2}\right) \\&amp;=\sigma_{X}^{2}\end{aligned}$$]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> fluid </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直观理解协方差矩阵</title>
      <link href="/2021/08/05/math/covariance-matrix/"/>
      <url>/2021/08/05/math/covariance-matrix/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文出自 <a href="https://zhuanlan.zhihu.com/p/349802953">https://zhuanlan.zhihu.com/p/349802953</a></p></blockquote><h2 id="1-概率论中的定义">1 概率论中的定义</h2><h3 id="随机变量：">随机变量：</h3><p>随机变量(Random Variable) X 是一个映射，把随机试验的结果与实数建立起了一一对应的关系。而期望与方差是随机变量的两个重要的数字特征。</p><h3 id="数学期望：">数学期望：</h3><p>在概率论和统计学中，数学期望(mean)(或均值，亦简称期望(Expectation, or expected value))是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。 期望值是该变量输出值的平均数。期望值并不一定包含于变量的输出值集合里。</p><p>大数定律规定，随着重复次数接近无穷大，数值的算术平均值几乎肯定地收敛于期望值。</p><h3 id="方差：">方差：</h3><p>方差(Variance)是在概率论和统计方差衡量随机变量或一组数据时离散程度的度量。概率论中方差用来度量随机变量和其数学期望(即均值)之间的偏离程度。统计中的方差(样本方差)是每个样本值与全体样本值的平均数之差的平方值的平均数。</p><p>设$X$为随机变量， 如果$\mathrm{E}[X]$，则随机变量$X$的方差为：<br>$$<br>\mu=\mathrm{E}[X]<br>$$</p><p>方差也记为 $\sigma_{X}^{2}$。</p><p>样本方差计算公式：</p><p>$$<br>S<sup>{2}=\Sigma\left(X-\overline{X}\right)</sup>{2}/\left(n-1\right)<br>$$</p><p>其中，$S^{2}$为样本方差，$X$ 为变量，$\overline{X}$为样本均值，$n$ 为样本例数。如果要了解为什么要除以$n-1$，请看<a href="https://link.zhihu.com/?target=https%3A//www.visiondummy.com/2014/03/divide-variance-n-1/">这篇文章</a>。</p><h3 id="标准差：">标准差：</h3><p>标准差(Standard Deviation)是离均差平方的算术平均数(即：方差)的算术平方根，用$\sigma$表示。标准差也被称为标准偏差，或者实验标准差，在概率统计中最常使用作为统计分布程度上的测量依据。 见下图：</p><p><img src="https://picture.mulindya.com/covariance-matrix-pic1.jpg" alt=""></p><p>标准差是方差的算术平方根。标准差能反映一个数据集的离散程度。平均数相同的两组数据，标准差未必相同。</p><h3 id="协方差：">协方差：</h3><p><strong>协方差(Covariance)在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</strong></p><p>期望值分别为$ E[X]$与$[Y]$的两个实随机变量$X$与$Y$之间的协方差 $\mathrm{Cov}(X,Y)$ 定义为：</p>$$\begin{aligned}\mathrm{Cov}(X,Y)&amp;=\mathrm{E}\left[\left(X\mathrm{E}\left[X\right]\right)\left(Y-\mathrm{E}\left[Y\right]\right)\right]  \\&amp;=\mathrm{E}\left[XY\right]-2\mathrm{E}\left[Y\right]\mathrm{E}\left[X\right]+\mathrm{E}\left[X\right]\mathrm{E}\left[Y\right]\\&amp;=\mathrm{E}\left[XY\right]-\mathrm{E}\left[X\right]\mathrm{E}\left[Y\right] \\&amp;=\mathrm{E}\left[XY\right]-\mathrm{E}\left[X\right]\mathrm{E}\left[Y\right]\end{aligned}$$<p>协方差表示的是两个变量总体误差的期望。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。</p><p>如果$X$与$Y$是统计独立的，那么二者之间的协方差就是0，因为两个独立的随机变量满足$\mathrm{E}[XY]=\mathrm{E}[X]\mathrm{E}[Y]$。但是，反过来并不成立。即如果$X$与$Y$的协方差为0，二者并不一定是统计独立的。</p><p><strong>协方差为0的两个随机变量称为是不相关的。</strong></p><h3 id="协方差矩阵：">协方差矩阵：</h3><p>在统计学与概率论中，协方差矩阵(Covariance matrix)的每个元素是各个向量元素之间的协方差，是从标量随机变量到高维度随机向量的自然推广。</p><p>设$X=\left(X_{1},X_{2},\ldots,X_{n}\right)^{\mathrm{T}}$为$n$ 维随机变量，称矩阵</p>$$C=\left(\begin{array}{cccc} c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1n}\\ c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2n}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\ c_{n1} &amp; c_{n2} &amp; \cdots &amp; c_{nn} \end{array}\right)$$<p>为 n 维随机变量x的协方差矩阵，也记为 $D\left(X\right)$ ，其中<br>$$<br>c_{ij}=\mathrm{Cov}(X_{i},X_{j}),\quad i,j=1,2,\ldots,n<br>$$<br>为X的分量$X_{i}$和$X_{j}$的协方差。<em>并且对角线上的元素为各个随机变量的方差：</em></p><p>$$<br>c_{ii}=\mathrm{Cov}(X_{i},X_{i}),\quad i=1,2,\ldots,n<br>$$</p><p>协方差矩阵是对称半正定矩阵。协方差矩阵的对称性，可从定义得知。对于半正定特性，证明如下：</p><p>现给定任意一个非零向量$\boldsymbol{x}$，则</p>$$\begin{aligned}\boldsymbol{x}^{\mathrm{T}}C\boldsymbol{x}&amp;=\boldsymbol{x}^{\mathrm{T}}\mathrm{E}\left[\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\right]\boldsymbol{x} \\&amp;=\mathrm{E}\left[\boldsymbol{x}^{\mathrm{T}}\left(X-\mu\right)\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right] \\&amp;=\mathrm{E}\left[\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)^{\mathrm{T}}\left(\left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right)\right] \\&amp;=\mathrm{E}\left(\left\Vert \left(X-\mu\right)^{\mathrm{T}}\boldsymbol{x}\right\Vert ^{2}\right) \\&amp;=\sigma_{X}^{2}\end{aligned}$$<p>其中，<br>$$<br>\sigma_{X}=\left(X-\mu \right)^{\mathrm{T}}\boldsymbol{x}<br>$$<br>由于 $\sigma_{X}<sup>{2}\geq0$，因此$\boldsymbol{x}</sup>{\mathrm{T}}C\boldsymbol{x}\geq0$，因此协方差矩阵$C$ 是半正定矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
